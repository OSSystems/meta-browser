Upstream-Status: Submitted [https://crrev.com/c/1570014]

Signed-off-by: Maksim Sisov <msisov@igalia.com>
---
From 2d442618f548098fbb9483823aaeb9c3d32d6536 Mon Sep 17 00:00:00 2001
From: Maksim Sisov <msisov@igalia.com>
Date: Thu, 18 Apr 2019 09:41:39 +0300
Subject: [PATCH 09/11] Ease the buffer swap and maintenance

This CL adds a Surface class, which has 1:1 relationship
with a WaylandWindow (whenever the former is created, the
manager is notified, and it creates an internal representation
of the window).

The CL does not bring any major changes, but rather improves
and eases the maintenance of buffers and distinguishes
buffers by the widget they have been created for.

This is a prerequisite to switch from post frame callback wait
to the pre frame callback wait.

Bug: 943096
Change-Id: Ia70f061c4c47a9675c2a018a346b6bc38d0e8cf7
---
 .../wayland/gpu/gbm_pixmap_wayland.cc         |   6 +-
 .../wayland/gpu/gbm_surfaceless_wayland.cc    |   1 +
 .../wayland/gpu/wayland_connection_proxy.cc   |  14 +-
 .../wayland/gpu/wayland_connection_proxy.h    |   6 +-
 .../wayland/host/wayland_buffer_manager.cc    | 589 +++++++++++-------
 .../wayland/host/wayland_buffer_manager.h     | 117 +---
 .../wayland/host/wayland_connection.cc        |  22 +-
 .../wayland/host/wayland_connection.h         |  11 +-
 .../wayland/wayland_connection.mojom          |  39 +-
 9 files changed, 456 insertions(+), 349 deletions(-)

diff --git a/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.cc b/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.cc
index 585a3d8f31c6..ee8d622f95cc 100644
--- a/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.cc
+++ b/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.cc
@@ -181,9 +181,9 @@ void GbmPixmapWayland::CreateZwpLinuxDmabuf() {
   base::File file(fd.release());
 
   // Asks Wayland to create a wl_buffer based on the |file| fd.
-  connection_->CreateZwpLinuxDmabuf(std::move(file), GetBufferSize(), strides,
-                                    offsets, modifiers, gbm_bo_->GetFormat(),
-                                    plane_count, GetUniqueId());
+  connection_->CreateZwpLinuxDmabuf(
+      widget_, std::move(file), GetBufferSize(), strides, offsets, modifiers,
+      gbm_bo_->GetFormat(), plane_count, GetUniqueId());
 }
 
 }  // namespace ui
diff --git a/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.cc b/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.cc
index e97eea1dbe7a..c348472bb3eb 100644
--- a/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.cc
+++ b/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.cc
@@ -258,6 +258,7 @@ void GbmSurfacelessWayland::OnSubmission(uint32_t buffer_id,
 void GbmSurfacelessWayland::OnPresentation(
     uint32_t buffer_id,
     const gfx::PresentationFeedback& feedback) {
+  DCHECK(!pending_presentation_frames_.empty());
   auto* frame = pending_presentation_frames_.front().get();
   DCHECK_EQ(frame->buffer_id, buffer_id);
   std::move(frame->presentation_callback).Run(feedback);
diff --git a/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.cc b/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.cc
index 0c46d34c4769..230ee57fe9d2 100644
--- a/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.cc
+++ b/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.cc
@@ -68,6 +68,7 @@ void WaylandConnectionProxy::OnPresentation(
 }
 
 void WaylandConnectionProxy::CreateZwpLinuxDmabuf(
+    gfx::AcceleratedWidget widget,
     base::File file,
     gfx::Size size,
     const std::vector<uint32_t>& strides,
@@ -82,13 +83,14 @@ void WaylandConnectionProxy::CreateZwpLinuxDmabuf(
   gpu_thread_runner_->PostTask(
       FROM_HERE,
       base::BindOnce(&WaylandConnectionProxy::CreateZwpLinuxDmabufInternal,
-                     base::Unretained(this), std::move(file), std::move(size),
-                     std::move(strides), std::move(offsets),
+                     base::Unretained(this), widget, std::move(file),
+                     std::move(size), std::move(strides), std::move(offsets),
                      std::move(modifiers), current_format, planes_count,
                      buffer_id));
 }
 
 void WaylandConnectionProxy::CreateZwpLinuxDmabufInternal(
+    gfx::AcceleratedWidget widget,
     base::File file,
     gfx::Size size,
     const std::vector<uint32_t>& strides,
@@ -106,9 +108,9 @@ void WaylandConnectionProxy::CreateZwpLinuxDmabufInternal(
 
   DCHECK(gpu_thread_runner_->BelongsToCurrentThread());
   DCHECK(wc_ptr_);
-  wc_ptr_->CreateZwpLinuxDmabuf(std::move(file), size.width(), size.height(),
-                                strides, offsets, current_format, modifiers,
-                                planes_count, buffer_id);
+  wc_ptr_->CreateZwpLinuxDmabuf(widget, std::move(file), size, strides, offsets,
+                                modifiers, current_format, planes_count,
+                                buffer_id);
 }
 
 void WaylandConnectionProxy::DestroyZwpLinuxDmabuf(
@@ -130,7 +132,7 @@ void WaylandConnectionProxy::DestroyZwpLinuxDmabufInternal(
   DCHECK(gpu_thread_runner_->BelongsToCurrentThread());
   DCHECK(wc_ptr_);
 
-  wc_ptr_->DestroyZwpLinuxDmabuf(buffer_id);
+  wc_ptr_->DestroyZwpLinuxDmabuf(widget, buffer_id);
 }
 
 void WaylandConnectionProxy::ScheduleBufferSwap(
diff --git a/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h b/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h
index 2335c93192fa..d507d06f03cb 100644
--- a/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h
+++ b/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h
@@ -62,7 +62,8 @@ class WaylandConnectionProxy : public ozone::mojom::WaylandConnectionClient {
   //
   // Asks Wayland to create a wl_buffer based on a shared buffer file
   // descriptor backed (gbm_bo).
-  void CreateZwpLinuxDmabuf(base::File file,
+  void CreateZwpLinuxDmabuf(gfx::AcceleratedWidget widget,
+                            base::File file,
                             gfx::Size size,
                             const std::vector<uint32_t>& strides,
                             const std::vector<uint32_t>& offsets,
@@ -135,7 +136,8 @@ class WaylandConnectionProxy : public ozone::mojom::WaylandConnectionClient {
   WaylandConnection* connection() const { return connection_; }
 
  private:
-  void CreateZwpLinuxDmabufInternal(base::File file,
+  void CreateZwpLinuxDmabufInternal(gfx::AcceleratedWidget widget,
+                                    base::File file,
                                     gfx::Size size,
                                     const std::vector<uint32_t>& strides,
                                     const std::vector<uint32_t>& offsets,
diff --git a/ui/ozone/platform/wayland/host/wayland_buffer_manager.cc b/ui/ozone/platform/wayland/host/wayland_buffer_manager.cc
index 0d1b328d62ef..99877e12bbc1 100644
--- a/ui/ozone/platform/wayland/host/wayland_buffer_manager.cc
+++ b/ui/ozone/platform/wayland/host/wayland_buffer_manager.cc
@@ -6,6 +6,8 @@
 
 #include <presentation-time-client-protocol.h>
 
+#include "base/i18n/number_formatting.h"
+#include "base/strings/utf_string_conversions.h"
 #include "base/trace_event/trace_event.h"
 #include "ui/ozone/common/linux/drm_util_linux.h"
 #include "ui/ozone/platform/wayland/host/wayland_connection.h"
@@ -41,47 +43,351 @@ base::TimeTicks GetPresentationFeedbackTimeStamp(uint32_t tv_sec_hi,
 
 }  // namespace
 
-WaylandBufferManager::Buffer::Buffer(const gfx::Size& buffer_size,
-                                     uint32_t buffer_id)
-    : size(buffer_size), buffer_id(buffer_id) {}
-WaylandBufferManager::Buffer::~Buffer() = default;
+class WaylandBufferManager::Surface {
+ public:
+  Surface(WaylandWindow* window, WaylandConnection* connection)
+      : window_(window), connection_(connection) {}
+  ~Surface() = default;
+
+  bool CommitBuffer(uint32_t buffer_id, const gfx::Rect& damage_region) {
+    DCHECK(!submitted_buffer_);
+
+    WaylandBuffer* buffer = GetBuffer(buffer_id);
+    if (!buffer)
+      return false;
+
+    // This request may come earlier than the Wayland compositor has imported a
+    // wl_buffer. Wait until the buffer is created. The wait takes place only
+    // once. Though, the case when a request to attach a buffer comes earlier
+    // than the wl_buffer is created does not happen often. 1) Depending on the
+    // zwp linux dmabuf protocol version, the wl_buffer can be created
+    // immediately without asynchronous wait 2) the wl_buffer can have been
+    // created by this time.
+    while (!buffer->wl_buffer) {
+      if (wl_display_dispatch(connection_->display()) == -1)
+        return false;
+    }
+
+    AttachAndDamageBuffer(buffer, damage_region);
+
+    SetupFrameCallback();
+    SetupPresentationFeedback(buffer_id);
+
+    CommitSurface();
+
+    connection_->ScheduleFlush();
+    return true;
+  }
+
+  bool CreateBuffer(const gfx::Size& size, uint32_t buffer_id) {
+    auto result = buffers_.insert(std::make_pair(
+        buffer_id, std::make_unique<WaylandBuffer>(size, buffer_id)));
+    return result.second;
+  }
+
+  size_t DestroyBuffer(uint32_t buffer_id) {
+    if (submitted_buffer_ && submitted_buffer_->buffer_id == buffer_id)
+      submitted_buffer_ = nullptr;
+    auto result = buffers_.erase(buffer_id);
+    return result;
+  }
+
+  void AttachWlBuffer(uint32_t buffer_id, wl::Object<wl_buffer> new_buffer) {
+    // It can happen that a buffer was destroyed by a client while the Wayland
+    // compositor was processing a request to create a wl_buffer.
+    WaylandBuffer* buffer = GetBuffer(buffer_id);
+    if (!buffer)
+      return;
+
+    DCHECK(!buffer->wl_buffer);
+    buffer->wl_buffer = std::move(new_buffer);
+  }
+
+  void ClearState() {
+    buffers_.clear();
+    wl_frame_callback_.reset();
+    base::queue<
+        std::pair<uint32_t, wl::Object<struct wp_presentation_feedback>>>
+        empty;
+    std::swap(presentation_feedbacks_, empty);
+  }
+
+ private:
+  // This is an internal helper representation of a wayland buffer object, which
+  // the GPU process creates when CreateBuffer is called. It's used for
+  // asynchronous buffer creation and stores |params| parameter to find out,
+  // which Buffer the wl_buffer corresponds to when CreateSucceeded is called.
+  // What is more, the Buffer stores such information as a widget it is attached
+  // to, its buffer id for simpler buffer management and other members specific
+  // to this Buffer object on run-time.
+  struct WaylandBuffer {
+    WaylandBuffer() = delete;
+    WaylandBuffer(const gfx::Size& size, uint32_t buffer_id);
+    ~WaylandBuffer();
+
+    // Actual buffer size.
+    const gfx::Size size;
+
+    // The id of this buffer.
+    const uint32_t buffer_id;
+
+    // A wl_buffer backed by a dmabuf created on the GPU side.
+    wl::Object<struct wl_buffer> wl_buffer;
+
+    gfx::PresentationFeedback feedback;
+
+    bool swapped = false;
+    bool presented = false;
+
+    DISALLOW_COPY_AND_ASSIGN(WaylandBuffer);
+  };
+
+  void AttachAndDamageBuffer(WaylandBuffer* buffer,
+                             const gfx::Rect& damage_region) {
+    gfx::Rect pending_damage_region = damage_region;
+    // If the size of the damage region is empty, wl_surface_damage must be
+    // supplied with the actual size of the buffer, which is going to be
+    // committed.
+    if (pending_damage_region.size().IsEmpty())
+      pending_damage_region.set_size(buffer->size);
+    DCHECK(!pending_damage_region.size().IsEmpty());
+
+    auto* surface = window_->surface();
+    wl_surface_damage_buffer(
+        surface, pending_damage_region.x(), pending_damage_region.y(),
+        pending_damage_region.width(), pending_damage_region.height());
+    wl_surface_attach(surface, buffer->wl_buffer.get(), 0, 0);
+
+    submitted_buffer_ = buffer;
+  }
+
+  void CommitSurface() { wl_surface_commit(window_->surface()); }
+
+  void SetupFrameCallback() {
+    static const wl_callback_listener frame_listener = {
+        &Surface::FrameCallbackDone};
+
+    DCHECK(!wl_frame_callback_);
+    wl_frame_callback_.reset(wl_surface_frame(window_->surface()));
+    wl_callback_add_listener(wl_frame_callback_.get(), &frame_listener, this);
+  }
+
+  void SetupPresentationFeedback(uint32_t buffer_id) {
+    // Set up presentation feedback.
+    if (!connection_->presentation())
+      return;
+
+    static const wp_presentation_feedback_listener feedback_listener = {
+        &Surface::FeedbackSyncOutput, &Surface::FeedbackPresented,
+        &Surface::FeedbackDiscarded};
+
+    presentation_feedbacks_.push(std::make_pair(
+        buffer_id,
+        wl::Object<struct wp_presentation_feedback>(wp_presentation_feedback(
+            connection_->presentation(), window_->surface()))));
+    wp_presentation_feedback_add_listener(
+        presentation_feedbacks_.back().second.get(), &feedback_listener, this);
+  }
+
+  WaylandBuffer* GetBuffer(uint32_t buffer_id) {
+    auto it = buffers_.find(buffer_id);
+    return it != buffers_.end() ? it->second.get() : nullptr;
+  }
+
+  void OnFrameCallback(struct wl_callback* callback) {
+    DCHECK(wl_frame_callback_.get() == callback);
+    wl_frame_callback_.reset();
+
+    if (!submitted_buffer_)
+      return;
+
+    // TODO(msisov): remove these once pending buffers logic goes to the
+    // manager as long as it will always notify about successful swap once the
+    // surface is committed.
+    DCHECK(submitted_buffer_);
+    WaylandBuffer* buffer = submitted_buffer_;
+    submitted_buffer_ = nullptr;
+
+    buffer->swapped = true;
+    DCHECK(connection_);
+    connection_->OnSubmission(window_->GetWidget(), buffer->buffer_id,
+                              gfx::SwapResult::SWAP_ACK);
+
+    // If presentation feedback is not supported, use a fake feedback. This
+    // literally means there are no presentation feedback callbacks created.
+    if (!connection_->presentation()) {
+      DCHECK(presentation_feedbacks_.empty() && !buffer->presented);
+      OnPresentation(
+          buffer->buffer_id,
+          gfx::PresentationFeedback(base::TimeTicks::Now(), base::TimeDelta(),
+                                    GetPresentationKindFlags(0)));
+    } else if (buffer->presented) {
+      // If the buffer has been presented before the frame callback aka
+      // completion callback (in the future, release callback is going to be
+      // used), present the feedback to the GPU.
+      OnPresentation(buffer->buffer_id, buffer->feedback);
+    } else {
+      DCHECK(!presentation_feedbacks_.empty());
+    }
+  }
+
+  // wl_callback_listener
+  static void FrameCallbackDone(void* data,
+                                struct wl_callback* callback,
+                                uint32_t time) {
+    Surface* self = static_cast<Surface*>(data);
+    if (self)
+      self->OnFrameCallback(callback);
+  }
+
+  void OnPresentation(uint32_t buffer_id,
+                      const gfx::PresentationFeedback& feedback) {
+    WaylandBuffer* buffer = GetBuffer(buffer_id);
+    DCHECK(buffer);
+
+    if (buffer->swapped) {
+      DCHECK(connection_);
+      connection_->OnPresentation(window_->GetWidget(), buffer_id, feedback);
+
+      buffer->swapped = false;
+      buffer->presented = false;
+    } else {
+      buffer->presented = true;
+      buffer->feedback = feedback;
+    }
+  }
+
+  // wp_presentation_feedback_listener
+  static void FeedbackSyncOutput(
+      void* data,
+      struct wp_presentation_feedback* wp_presentation_feedback,
+      struct wl_output* output) {}
+
+  static void FeedbackPresented(
+      void* data,
+      struct wp_presentation_feedback* wp_presentation_feedback,
+      uint32_t tv_sec_hi,
+      uint32_t tv_sec_lo,
+      uint32_t tv_nsec,
+      uint32_t refresh,
+      uint32_t seq_hi,
+      uint32_t seq_lo,
+      uint32_t flags) {
+    Surface* self = static_cast<Surface*>(data);
+    if (self) {
+      auto presentation = std::move(self->presentation_feedbacks_.front());
+      DCHECK(presentation.second.get() == wp_presentation_feedback);
+      self->presentation_feedbacks_.pop();
+      self->OnPresentation(
+          presentation.first,
+          gfx::PresentationFeedback(
+              GetPresentationFeedbackTimeStamp(tv_sec_hi, tv_sec_lo, tv_nsec),
+              base::TimeDelta::FromNanoseconds(refresh),
+              GetPresentationKindFlags(flags)));
+    }
+  }
+
+  static void FeedbackDiscarded(
+      void* data,
+      struct wp_presentation_feedback* wp_presentation_feedback) {
+    Surface* self = static_cast<Surface*>(data);
+    if (self) {
+      auto presentation = std::move(self->presentation_feedbacks_.front());
+      DCHECK(presentation.second.get() == wp_presentation_feedback);
+      self->presentation_feedbacks_.pop();
+      self->OnPresentation(presentation.first,
+                           gfx::PresentationFeedback::Failure());
+    }
+  }
+
+  // Widget this helper surface backs and has 1:1 relationship with the
+  // WaylandWindow.
+
+  // Non-owned. The window this helper surface stores and submits buffers for.
+  const WaylandWindow* const window_;
+
+  // Non-owned pointer to the connection.
+  WaylandConnection* const connection_;
+
+  // A buffer the surface has committed. Reset on frame callback.
+  WaylandBuffer* submitted_buffer_ = nullptr;
+
+  // A container of created buffers.
+  base::flat_map<uint32_t, std::unique_ptr<WaylandBuffer>> buffers_;
+
+  // A Wayland callback, which is triggered once wl_buffer has been committed
+  // and it is right time to notify the GPU that it can start a new drawing
+  // operation.
+  wl::Object<wl_callback> wl_frame_callback_;
+
+  // A presentation feedback provided by the Wayland server once frame is
+  // shown.
+  base::queue<std::pair<uint32_t, wl::Object<struct wp_presentation_feedback>>>
+      presentation_feedbacks_;
+
+  DISALLOW_COPY_AND_ASSIGN(Surface);
+};
+
+WaylandBufferManager::Surface::WaylandBuffer::WaylandBuffer(
+    const gfx::Size& size,
+    uint32_t buffer_id)
+    : size(size), buffer_id(buffer_id) {}
+WaylandBufferManager::Surface::WaylandBuffer::~WaylandBuffer() = default;
 
 WaylandBufferManager::WaylandBufferManager(WaylandConnection* connection)
     : connection_(connection), weak_factory_(this) {}
 
 WaylandBufferManager::~WaylandBufferManager() {
-  DCHECK(buffers_.empty());
+  DCHECK(surfaces_.empty());
 }
 
-bool WaylandBufferManager::CreateBuffer(base::File file,
-                                        uint32_t width,
-                                        uint32_t height,
+void WaylandBufferManager::OnWindowAdded(WaylandWindow* window) {
+  DCHECK(window);
+  surfaces_[window->GetWidget()] =
+      std::make_unique<Surface>(window, connection_);
+}
+
+void WaylandBufferManager::OnWindowRemoved(WaylandWindow* window) {
+  DCHECK(window);
+  DCHECK(surfaces_.erase(window->GetWidget()));
+}
+
+bool WaylandBufferManager::CreateBuffer(gfx::AcceleratedWidget widget,
+                                        base::File file,
+                                        const gfx::Size& size,
                                         const std::vector<uint32_t>& strides,
                                         const std::vector<uint32_t>& offsets,
-                                        uint32_t format,
                                         const std::vector<uint64_t>& modifiers,
+                                        uint32_t format,
                                         uint32_t planes_count,
                                         uint32_t buffer_id) {
   TRACE_EVENT2("wayland", "WaylandBufferManager::CreateZwpLinuxDmabuf",
                "Format", format, "Buffer id", buffer_id);
 
-  if (!ValidateDataFromGpu(file, width, height, strides, offsets, format,
-                           modifiers, planes_count, buffer_id)) {
+  if (!ValidateDataFromGpu(widget, file, size, strides, offsets, modifiers,
+                           format, planes_count, buffer_id)) {
     // base::File::Close() has an assertion that checks if blocking operations
     // are allowed. Thus, manually close the fd here.
     base::ScopedFD deleter(file.TakePlatformFile());
     return false;
   }
 
-  std::unique_ptr<Buffer> buffer =
-      std::make_unique<Buffer>(gfx::Size(width, height), buffer_id);
-  buffers_.insert(std::make_pair(buffer_id, std::move(buffer)));
+  WaylandBufferManager::Surface* surface = GetSurface(widget);
+  DCHECK(surface);
+
+  if (!surface->CreateBuffer(size, buffer_id)) {
+    error_message_ = "A buffer with id= " +
+                     base::UTF16ToUTF8(base::FormatNumber(buffer_id)) +
+                     " already exists";
+    return false;
+  }
 
+  // Create wl_buffer associated with the internal Buffer.
   auto callback = base::BindOnce(&WaylandBufferManager::OnCreateBufferComplete,
-                                 weak_factory_.GetWeakPtr(), buffer_id);
-  connection_->zwp_dmabuf()->CreateBuffer(
-      std::move(file), gfx::Size(width, height), strides, offsets, modifiers,
-      format, planes_count, std::move(callback));
+                                 weak_factory_.GetWeakPtr(), widget, buffer_id);
+  connection_->zwp_dmabuf()->CreateBuffer(std::move(file), size, strides,
+                                          offsets, modifiers, format,
+                                          planes_count, std::move(callback));
   return true;
 }
 
@@ -94,111 +400,76 @@ bool WaylandBufferManager::ScheduleBufferSwap(gfx::AcceleratedWidget widget,
   if (!ValidateDataFromGpu(widget, buffer_id))
     return false;
 
-  auto it = buffers_.find(buffer_id);
-  if (it == buffers_.end()) {
-    error_message_ =
-        "Buffer with " + std::to_string(buffer_id) + " id does not exist";
+  Surface* surface = GetSurface(widget);
+  if (!surface) {
+    error_message_ = "Surface does not exist";
     return false;
   }
 
-  Buffer* buffer = it->second.get();
-  DCHECK(buffer);
-  DCHECK(!buffer->swapped && !buffer->presented);
-
-  // Assign a widget to this buffer, which is used to find a corresponding
-  // WaylandWindow.
-  buffer->widget = widget;
-  buffer->damage_region = damage_region;
-
-  if (buffer->wl_buffer) {
-    // A wl_buffer might not exist by this time. Silently return.
-    // TODO: check this.
-    return SwapBuffer(buffer);
-  }
-  return true;
+  return SwapBuffer(surface, buffer_id, damage_region);
 }
 
-bool WaylandBufferManager::DestroyBuffer(uint32_t buffer_id) {
+bool WaylandBufferManager::DestroyBuffer(gfx::AcceleratedWidget widget,
+                                         uint32_t buffer_id) {
   TRACE_EVENT1("wayland", "WaylandBufferManager::DestroyZwpLinuxDmabuf",
                "Buffer id", buffer_id);
 
-  auto it = buffers_.find(buffer_id);
-  if (it == buffers_.end()) {
-    error_message_ = "Trying to destroy non-existing buffer";
+  Surface* surface = GetSurface(widget);
+  // On browser shutdown, the surface might have already been destroyed.
+  if (!surface)
+    return true;
+
+  if (surface->DestroyBuffer(buffer_id) != 1u) {
+    error_message_ = "Buffer with " +
+                     base::UTF16ToUTF8(base::FormatNumber(buffer_id)) +
+                     " id does not exist";
     return false;
   }
 
-  buffers_.erase(it);
-
   connection_->ScheduleFlush();
   return true;
 }
 
 void WaylandBufferManager::ClearState() {
-  buffers_.clear();
+  for (auto& surface_pair : surfaces_)
+    surface_pair.second->ClearState();
 }
 
-// TODO(msisov): handle buffer swap failure or success.
-bool WaylandBufferManager::SwapBuffer(Buffer* buffer) {
-  WaylandWindow* window = connection_->GetWindow(buffer->widget);
-  if (!window) {
-    error_message_ = "A WaylandWindow with current widget does not exist";
-    return false;
-  }
+WaylandBufferManager::Surface* WaylandBufferManager::GetSurface(
+    gfx::AcceleratedWidget widget) const {
+  auto it = surfaces_.find(widget);
+  return it != surfaces_.end() ? it->second.get() : nullptr;
+}
 
-  gfx::Rect damage_region = buffer->damage_region;
-  // If the size of the damage region is empty, wl_surface_damage must be
-  // supplied with the actual size of the buffer, which is going to be
-  // committed.
-  if (damage_region.size().IsEmpty())
-    damage_region.set_size(buffer->size);
-
-  wl_surface_damage_buffer(window->surface(), damage_region.x(),
-                           damage_region.y(), damage_region.width(),
-                           damage_region.height());
-  wl_surface_attach(window->surface(), buffer->wl_buffer.get(), 0, 0);
-
-  static const wl_callback_listener frame_listener = {
-      WaylandBufferManager::FrameCallbackDone};
-  DCHECK(!buffer->wl_frame_callback);
-  buffer->wl_frame_callback.reset(wl_surface_frame(window->surface()));
-  wl_callback_add_listener(buffer->wl_frame_callback.get(), &frame_listener,
-                           this);
-
-  // Set up presentation feedback.
-  static const wp_presentation_feedback_listener feedback_listener = {
-      WaylandBufferManager::FeedbackSyncOutput,
-      WaylandBufferManager::FeedbackPresented,
-      WaylandBufferManager::FeedbackDiscarded};
-  if (connection_->presentation()) {
-    DCHECK(!buffer->wp_presentation_feedback);
-    buffer->wp_presentation_feedback.reset(wp_presentation_feedback(
-        connection_->presentation(), window->surface()));
-    wp_presentation_feedback_add_listener(
-        buffer->wp_presentation_feedback.get(), &feedback_listener, this);
+bool WaylandBufferManager::SwapBuffer(Surface* surface,
+                                      uint32_t buffer_id,
+                                      const gfx::Rect& damage_region) {
+  if (!surface->CommitBuffer(buffer_id, damage_region)) {
+    error_message_ = "Buffer with " +
+                     base::UTF16ToUTF8(base::FormatNumber(buffer_id)) +
+                     " id does not exist";
   }
-
-  wl_surface_commit(window->surface());
-
-  connection_->ScheduleFlush();
-  return true;
+  return error_message_.empty();
 }
 
 bool WaylandBufferManager::ValidateDataFromGpu(
+    const gfx::AcceleratedWidget& widget,
     const base::File& file,
-    uint32_t width,
-    uint32_t height,
+    const gfx::Size& size,
     const std::vector<uint32_t>& strides,
     const std::vector<uint32_t>& offsets,
-    uint32_t format,
     const std::vector<uint64_t>& modifiers,
+    uint32_t format,
     uint32_t planes_count,
     uint32_t buffer_id) {
+  if (!ValidateDataFromGpu(widget, buffer_id))
+    return false;
+
   std::string reason;
   if (!file.IsValid())
     reason = "Buffer fd is invalid";
 
-  if (width == 0 || height == 0)
+  if (size.IsEmpty())
     reason = "Buffer size is invalid";
 
   if (planes_count < 1)
@@ -221,15 +492,6 @@ bool WaylandBufferManager::ValidateDataFromGpu(
   if (!IsValidBufferFormat(format))
     reason = "Buffer format is invalid";
 
-  if (buffer_id < 1)
-    reason = "Invalid buffer id: " + std::to_string(buffer_id);
-
-  auto it = buffers_.find(buffer_id);
-  if (it != buffers_.end()) {
-    reason = "A buffer with " + std::to_string(buffer_id) +
-             " id has already existed";
-  }
-
   if (!reason.empty()) {
     error_message_ = std::move(reason);
     return false;
@@ -241,7 +503,6 @@ bool WaylandBufferManager::ValidateDataFromGpu(
     const gfx::AcceleratedWidget& widget,
     uint32_t buffer_id) {
   std::string reason;
-
   if (widget == gfx::kNullAcceleratedWidget)
     reason = "Invalid accelerated widget";
 
@@ -257,133 +518,15 @@ bool WaylandBufferManager::ValidateDataFromGpu(
 }
 
 void WaylandBufferManager::OnCreateBufferComplete(
+    gfx::AcceleratedWidget widget,
     uint32_t buffer_id,
     wl::Object<struct wl_buffer> new_buffer) {
-  auto it = buffers_.find(buffer_id);
-  // It can happen that buffer was destroyed by a client while the Wayland
-  // compositor was processing a request to create a wl_buffer.
-  if (it == buffers_.end())
+  Surface* surface = GetSurface(widget);
+  // A surface can have been destroyed if it does not have buffers left.
+  if (!surface)
     return;
 
-  Buffer* buffer = it->second.get();
-  buffer->wl_buffer = std::move(new_buffer);
-
-  if (buffer->widget != gfx::kNullAcceleratedWidget)
-    SwapBuffer(buffer);
-}
-
-void WaylandBufferManager::OnSubmission(Buffer* buffer,
-                                        const gfx::SwapResult& swap_result) {
-  DCHECK(!buffer->swapped);
-
-  buffer->wl_frame_callback.reset();
-  buffer->swapped = true;
-  connection_->OnSubmission(buffer->widget, buffer->buffer_id,
-                            gfx::SwapResult::SWAP_ACK);
-
-  // If presentation feedback is not supported, use a fake feedback.
-  if (!connection_->presentation()) {
-    DCHECK(!buffer->wp_presentation_feedback && !buffer->presented);
-    OnPresentation(buffer, gfx::PresentationFeedback(base::TimeTicks::Now(),
-                                                     base::TimeDelta(), 0));
-  } else if (buffer->presented) {
-    DCHECK(!buffer->wp_presentation_feedback);
-    // If the buffer has been presented before the frame callback aka
-    // completion callback (in the future, release callback is going to be
-    // used), present the feedback to the GPU.
-    OnPresentation(buffer, buffer->feedback);
-  } else {
-    DCHECK(buffer->wp_presentation_feedback);
-  }
-}
-
-void WaylandBufferManager::OnPresentation(
-    Buffer* buffer,
-    const gfx::PresentationFeedback& feedback) {
-  buffer->presented = true;
-  buffer->feedback = feedback;
-
-  // If buffer has already been swapped, we can safely notify about the
-  // presentation as well.
-  if (buffer->swapped) {
-    connection_->OnPresentation(buffer->widget, buffer->buffer_id,
-                                buffer->feedback);
-
-    // Reset the status so that DCHECK passes in ::ScheduleBufferSwap call.
-    buffer->presented = false;
-    buffer->swapped = false;
-  }
-}
-
-// static
-void WaylandBufferManager::FrameCallbackDone(void* data,
-                                             wl_callback* callback,
-                                             uint32_t time) {
-  WaylandBufferManager* self = static_cast<WaylandBufferManager*>(data);
-  DCHECK(self);
-
-  for (auto& item : self->buffers_) {
-    Buffer* buffer = item.second.get();
-    if (buffer->wl_frame_callback.get() == callback) {
-      buffer->wl_frame_callback.reset();
-      self->OnSubmission(buffer, gfx::SwapResult::SWAP_ACK);
-      return;
-    }
-  }
-}
-
-// static
-void WaylandBufferManager::FeedbackSyncOutput(
-    void* data,
-    struct wp_presentation_feedback* wp_presentation_feedback,
-    struct wl_output* output) {
-  NOTIMPLEMENTED_LOG_ONCE();
-}
-
-// static
-void WaylandBufferManager::FeedbackPresented(
-    void* data,
-    struct wp_presentation_feedback* wp_presentation_feedback,
-    uint32_t tv_sec_hi,
-    uint32_t tv_sec_lo,
-    uint32_t tv_nsec,
-    uint32_t refresh,
-    uint32_t seq_hi,
-    uint32_t seq_lo,
-    uint32_t flags) {
-  WaylandBufferManager* self = static_cast<WaylandBufferManager*>(data);
-  DCHECK(self);
-  for (auto& item : self->buffers_) {
-    Buffer* buffer = item.second.get();
-    if (buffer->wp_presentation_feedback.get() == wp_presentation_feedback) {
-      DCHECK(!buffer->presented);
-      buffer->wp_presentation_feedback.reset();
-      self->OnPresentation(
-          buffer,
-          gfx::PresentationFeedback(
-              GetPresentationFeedbackTimeStamp(tv_sec_hi, tv_sec_lo, tv_nsec),
-              base::TimeDelta::FromNanoseconds(refresh),
-              GetPresentationKindFlags(flags)));
-      return;
-    }
-  }
-}
-
-// static
-void WaylandBufferManager::FeedbackDiscarded(
-    void* data,
-    struct wp_presentation_feedback* wp_presentation_feedback) {
-  WaylandBufferManager* self = static_cast<WaylandBufferManager*>(data);
-  DCHECK(self);
-  for (auto& item : self->buffers_) {
-    Buffer* buffer = item.second.get();
-    if (buffer->wp_presentation_feedback.get() == wp_presentation_feedback) {
-      DCHECK(!buffer->presented);
-      buffer->wp_presentation_feedback.reset();
-      self->OnPresentation(buffer, gfx::PresentationFeedback::Failure());
-      return;
-    }
-  }
+  surface->AttachWlBuffer(buffer_id, std::move(new_buffer));
 }
 
 }  // namespace ui
diff --git a/ui/ozone/platform/wayland/host/wayland_buffer_manager.h b/ui/ozone/platform/wayland/host/wayland_buffer_manager.h
index f4b0183cc3a1..eac05d955416 100644
--- a/ui/ozone/platform/wayland/host/wayland_buffer_manager.h
+++ b/ui/ozone/platform/wayland/host/wayland_buffer_manager.h
@@ -19,14 +19,14 @@
 #include "ui/ozone/platform/wayland/common/wayland_object.h"
 #include "ui/ozone/platform/wayland/common/wayland_util.h"
 
-struct wp_presentation_feedback;
-
 namespace ui {
 
 class WaylandConnection;
+class WaylandWindow;
 
 // The manager uses zwp_linux_dmabuf protocol to create wl_buffers from added
-// dmabuf buffers. Only used when GPU runs in own process.
+// dmabuf buffers, and uses internal representation of surfaces, which store
+// buffers associated with the WaylandWindow.
 class WaylandBufferManager {
  public:
   explicit WaylandBufferManager(WaylandConnection* connection);
@@ -34,15 +34,18 @@ class WaylandBufferManager {
 
   std::string error_message() { return std::move(error_message_); }
 
+  void OnWindowAdded(WaylandWindow* window);
+  void OnWindowRemoved(WaylandWindow* window);
+
   // Creates a wl_buffer based on the dmabuf |file| descriptor. On error, false
   // is returned and |error_message_| is set.
-  bool CreateBuffer(base::File file,
-                    uint32_t width,
-                    uint32_t height,
+  bool CreateBuffer(gfx::AcceleratedWidget widget,
+                    base::File file,
+                    const gfx::Size& size,
                     const std::vector<uint32_t>& strides,
                     const std::vector<uint32_t>& offsets,
-                    uint32_t format,
                     const std::vector<uint64_t>& modifiers,
+                    uint32_t format,
                     uint32_t planes_count,
                     uint32_t buffer_id);
 
@@ -59,72 +62,32 @@ class WaylandBufferManager {
 
   // Destroys a buffer with |buffer_id| in |buffers_|. On error, false is
   // returned and |error_message_| is set.
-  bool DestroyBuffer(uint32_t buffer_id);
+  bool DestroyBuffer(gfx::AcceleratedWidget widget, uint32_t buffer_id);
 
   // Destroys all the data and buffers stored in own containers.
   void ClearState();
 
  private:
-  // This is an internal helper representation of a wayland buffer object, which
-  // the GPU process creates when CreateBuffer is called. It's used for
-  // asynchronous buffer creation and stores |params| parameter to find out,
-  // which Buffer the wl_buffer corresponds to when CreateSucceeded is called.
-  // What is more, the Buffer stores such information as a widget it is attached
-  // to, its buffer id for simplier buffer management and other members specific
-  // to this Buffer object on run-time.
-  struct Buffer {
-    Buffer() = delete;
-    Buffer(const gfx::Size& buffer_size, uint32_t buffer_id);
-    ~Buffer();
-
-    // Actual buffer size.
-    const gfx::Size size;
-
-    // The id of the buffer.
-    const uint32_t buffer_id;
-
-    // Widget to attached/being attach WaylandWindow.
-    gfx::AcceleratedWidget widget = gfx::kNullAcceleratedWidget;
-
-    // Describes the region where the pending buffer is different from the
-    // current surface contents, and where the surface therefore needs to be
-    // repainted.
-    gfx::Rect damage_region;
+  // This is an internal representation of a real surface, which holds a pointer
+  // to WaylandWindow. Also, this object holds buffers, frame callbacks and
+  // presentation callbacks for that window's surface.
+  class Surface;
 
-    // A feedback, which is received if a presentation feedback protocol is
-    // supported.
-    gfx::PresentationFeedback feedback;
+  Surface* GetSurface(gfx::AcceleratedWidget widget) const;
 
-    // A wl_buffer backed by a dmabuf created on the GPU side.
-    wl::Object<struct wl_buffer> wl_buffer;
-
-    // Provide the status of this buffer. Reset on each new swap.
-    bool swapped = false;
-    bool presented = false;
-
-    // A Wayland callback, which is triggered once wl_buffer has been committed
-    // and it is right time to notify the GPU that it can start a new drawing
-    // operation.
-    wl::Object<wl_callback> wl_frame_callback;
-
-    // A presentation feedback provided by the Wayland server once frame is
-    // shown.
-    wl::Object<struct wp_presentation_feedback> wp_presentation_feedback;
-
-    DISALLOW_COPY_AND_ASSIGN(Buffer);
-  };
-
-  bool SwapBuffer(Buffer* buffer);
+  bool SwapBuffer(Surface* surface,
+                  uint32_t buffer_id,
+                  const gfx::Rect& damage_region);
 
   // Validates data sent from GPU. If invalid, returns false and sets an error
   // message to |error_message_|.
-  bool ValidateDataFromGpu(const base::File& file,
-                           uint32_t width,
-                           uint32_t height,
+  bool ValidateDataFromGpu(const gfx::AcceleratedWidget& widget,
+                           const base::File& file,
+                           const gfx::Size& size,
                            const std::vector<uint32_t>& strides,
                            const std::vector<uint32_t>& offsets,
-                           uint32_t format,
                            const std::vector<uint64_t>& modifiers,
+                           uint32_t format,
                            uint32_t planes_count,
                            uint32_t buffer_id);
   bool ValidateDataFromGpu(const gfx::AcceleratedWidget& widget,
@@ -132,39 +95,11 @@ class WaylandBufferManager {
 
   // Callback method. Receives a result for the request to create a wl_buffer
   // backend by dmabuf file descriptor from ::CreateBuffer call.
-  void OnCreateBufferComplete(uint32_t buffer_id,
+  void OnCreateBufferComplete(gfx::AcceleratedWidget widget,
+                              uint32_t buffer_id,
                               wl::Object<struct wl_buffer> new_buffer);
 
-  void OnSubmission(Buffer* buffer, const gfx::SwapResult& swap_result);
-  void OnPresentation(Buffer* buffer,
-                      const gfx::PresentationFeedback& feedback);
-
-  // wl_callback_listener
-  static void FrameCallbackDone(void* data,
-                                wl_callback* callback,
-                                uint32_t time);
-
-  // wp_presentation_feedback_listener
-  static void FeedbackSyncOutput(
-      void* data,
-      struct wp_presentation_feedback* wp_presentation_feedback,
-      struct wl_output* output);
-  static void FeedbackPresented(
-      void* data,
-      struct wp_presentation_feedback* wp_presentation_feedback,
-      uint32_t tv_sec_hi,
-      uint32_t tv_sec_lo,
-      uint32_t tv_nsec,
-      uint32_t refresh,
-      uint32_t seq_hi,
-      uint32_t seq_lo,
-      uint32_t flags);
-  static void FeedbackDiscarded(
-      void* data,
-      struct wp_presentation_feedback* wp_presentation_feedback);
-
-  // A container of created buffers.
-  base::flat_map<uint32_t, std::unique_ptr<Buffer>> buffers_;
+  base::flat_map<gfx::AcceleratedWidget, std::unique_ptr<Surface>> surfaces_;
 
   // Set when invalid data is received from the GPU process.
   std::string error_message_;
diff --git a/ui/ozone/platform/wayland/host/wayland_connection.cc b/ui/ozone/platform/wayland/host/wayland_connection.cc
index 7604e9abd4a4..010f7a75d23d 100644
--- a/ui/ozone/platform/wayland/host/wayland_connection.cc
+++ b/ui/ozone/platform/wayland/host/wayland_connection.cc
@@ -159,12 +159,19 @@ WaylandWindow* WaylandConnection::GetCurrentKeyboardFocusedWindow() const {
 
 void WaylandConnection::AddWindow(gfx::AcceleratedWidget widget,
                                   WaylandWindow* window) {
+  DCHECK(buffer_manager_);
+  buffer_manager_->OnWindowAdded(window);
+
   window_map_[widget] = window;
 }
 
 void WaylandConnection::RemoveWindow(gfx::AcceleratedWidget widget) {
   if (touch_)
     touch_->RemoveTouchPoints(window_map_[widget]);
+
+  DCHECK(buffer_manager_);
+  buffer_manager_->OnWindowRemoved(window_map_[widget]);
+
   window_map_.erase(widget);
 }
 
@@ -188,30 +195,31 @@ void WaylandConnection::SetWaylandConnectionClient(
 }
 
 void WaylandConnection::CreateZwpLinuxDmabuf(
+    gfx::AcceleratedWidget widget,
     base::File file,
-    uint32_t width,
-    uint32_t height,
+    const gfx::Size& size,
     const std::vector<uint32_t>& strides,
     const std::vector<uint32_t>& offsets,
-    uint32_t format,
     const std::vector<uint64_t>& modifiers,
+    uint32_t format,
     uint32_t planes_count,
     uint32_t buffer_id) {
   DCHECK(base::MessageLoopCurrentForUI::IsSet());
 
   DCHECK(buffer_manager_);
-  if (!buffer_manager_->CreateBuffer(std::move(file), width, height, strides,
-                                     offsets, format, modifiers, planes_count,
+  if (!buffer_manager_->CreateBuffer(widget, std::move(file), size, strides,
+                                     offsets, modifiers, format, planes_count,
                                      buffer_id)) {
     TerminateGpuProcess(buffer_manager_->error_message());
   }
 }
 
-void WaylandConnection::DestroyZwpLinuxDmabuf(uint32_t buffer_id) {
+void WaylandConnection::DestroyZwpLinuxDmabuf(gfx::AcceleratedWidget widget,
+                                              uint32_t buffer_id) {
   DCHECK(base::MessageLoopCurrentForUI::IsSet());
 
   DCHECK(buffer_manager_);
-  if (!buffer_manager_->DestroyBuffer(buffer_id)) {
+  if (!buffer_manager_->DestroyBuffer(widget, buffer_id)) {
     TerminateGpuProcess(buffer_manager_->error_message());
   }
 }
diff --git a/ui/ozone/platform/wayland/host/wayland_connection.h b/ui/ozone/platform/wayland/host/wayland_connection.h
index 2edbdb7e403d..5ffc6191599c 100644
--- a/ui/ozone/platform/wayland/host/wayland_connection.h
+++ b/ui/ozone/platform/wayland/host/wayland_connection.h
@@ -57,17 +57,18 @@ class WaylandConnection : public PlatformEventSource,
   //
   // Called by the GPU and asks to import a wl_buffer based on a gbm file
   // descriptor.
-  void CreateZwpLinuxDmabuf(base::File file,
-                            uint32_t width,
-                            uint32_t height,
+  void CreateZwpLinuxDmabuf(gfx::AcceleratedWidget widget,
+                            base::File file,
+                            const gfx::Size& size,
                             const std::vector<uint32_t>& strides,
                             const std::vector<uint32_t>& offsets,
-                            uint32_t format,
                             const std::vector<uint64_t>& modifiers,
+                            uint32_t format,
                             uint32_t planes_count,
                             uint32_t buffer_id) override;
   // Called by the GPU to destroy the imported wl_buffer with a |buffer_id|.
-  void DestroyZwpLinuxDmabuf(uint32_t buffer_id) override;
+  void DestroyZwpLinuxDmabuf(gfx::AcceleratedWidget widget,
+                             uint32_t buffer_id) override;
   // Called by the GPU and asks to attach a wl_buffer with a |buffer_id| to a
   // WaylandWindow with the specified |widget|.
   // Calls OnSubmission and OnPresentation on successful swap and pixels
diff --git a/ui/ozone/public/interfaces/wayland/wayland_connection.mojom b/ui/ozone/public/interfaces/wayland/wayland_connection.mojom
index 713ac9a210e7..8272883d7190 100644
--- a/ui/ozone/public/interfaces/wayland/wayland_connection.mojom
+++ b/ui/ozone/public/interfaces/wayland/wayland_connection.mojom
@@ -19,21 +19,36 @@ interface WaylandConnection {
 
   // Methods used for hardware accelerated rendering:
   //
-  // Asks Wayland to create a wl_buffer based on the dmabuf |file| descriptor.
-  CreateZwpLinuxDmabuf(mojo_base.mojom.File file,
-                            uint32 width,
-                            uint32 height,
-                            array<uint32> strides,
-                            array<uint32> offsets,
-                            uint32 format,
-                            array<uint64> modifiers,
-                            uint32 planes_count,
-                            uint32 buffer_id);
+  // Asks Wayland to create a wl_buffer based on the dmabuf |file| descriptor
+  // for the WaylandWindow, which has the following |widget|. The |size|
+  // is the size of the buffer, the |strides|, |offsets| and |modifiers|
+  // are the descriptions of the drm buffer object. The |format| describes
+  // the buffer format (check gfx::BufferFormat) in fourcc form. The
+  // |planes_count| says how many planes the buffer, backed by the |file|
+  // descriptor has. And the |buffer_id| is a unique id for the buffer, which
+  // is used to identify imported wl_buffers on the browser process side and
+  // map them with the buffer objects on the gpu process side.
+  CreateZwpLinuxDmabuf(gfx.mojom.AcceleratedWidget widget,
+                       mojo_base.mojom.File file,
+                       gfx.mojom.Size size,
+                       array<uint32> strides,
+                       array<uint32> offsets,
+                       array<uint64> modifiers,
+                       uint32 format,
+                       uint32 planes_count,
+                       uint32 buffer_id);
 
-  // Destroys a wl_buffer created by WaylandConnection based on the |buffer_id|.
-  DestroyZwpLinuxDmabuf(uint32 buffer_id);
+  // Destroys a wl_buffer created by WaylandConnection based on the |buffer_id|
+  // for the WaylandWindow, which has the following |widget|. The |buffer_id|
+  // is the unique id of the buffer objects being destroyed on the browser
+  // process side.
+  DestroyZwpLinuxDmabuf(gfx.mojom.AcceleratedWidget widget, uint32 buffer_id);
 
   // Swaps wl_buffers for a WaylandWindow with the following |widget|.
+  // The |damage_region| describes changed the region of the buffer.
+  // The |buffer_id| is a unique id for the buffer, which is used to
+  // identify imported wl_buffers on the browser process side mapped with
+  // the ones on the gpu process.
   ScheduleBufferSwap(gfx.mojom.AcceleratedWidget widget, uint32 buffer_id,
                      gfx.mojom.Rect damage_region);
 
-- 
2.17.1

