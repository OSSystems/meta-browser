Upstream-Status: Backport

* Backported from the ToT: https://crrev.com/c/1402882

Signed-off-by: Maksim Sisov <msisov@igalia.com>
---
From c42eee720220fb5a6f09220b57a172bee373dcd8 Mon Sep 17 00:00:00 2001
From: Maksim Sisov <msisov@igalia.com>
Date: Mon, 14 Jan 2019 07:48:48 +0000
Subject: [PATCH 03/16] [ozone/wayland]: WaylandScreen: return widget on screen
 point.

This change implements a method, which returns a widget on
a screen point. This method is needed, for example, to
properly update cursors (done by
RenderWidgetHostViewAura::UpdateCursorIfOverSelf) and etc.

As long as it's not possible to get windows on global
screen cordinates, use a focused windows instead (
the one under a pointer), and check if it contains the point.

Bug: 875161

Change-Id: I7187d54ea38ac3196503758de93e06e7882042d9
Reviewed-on: https://chromium-review.googlesource.com/c/1402882
Reviewed-by: Michael Spang <spang@chromium.org>
Reviewed-by: Robert Kroeger <rjkroege@chromium.org>
Commit-Queue: Maksim Sisov <msisov@igalia.com>
Cr-Commit-Position: refs/heads/master@{#622393}
---
 .../wayland/ozone_platform_wayland.cc         |   3 +-
 ui/ozone/platform/wayland/wayland_object.h    |   2 +-
 .../wayland/wayland_output_manager.cc         |   5 +-
 .../platform/wayland/wayland_output_manager.h |   4 +-
 ui/ozone/platform/wayland/wayland_screen.cc   |  17 ++-
 ui/ozone/platform/wayland/wayland_screen.h    |   6 +-
 .../wayland/wayland_screen_unittest.cc        | 105 +++++++++++++++---
 ui/ozone/platform/wayland/wayland_window.cc   |  12 +-
 ui/ozone/platform/wayland/wayland_window.h    |   2 +
 9 files changed, 123 insertions(+), 33 deletions(-)

diff --git a/ui/ozone/platform/wayland/ozone_platform_wayland.cc b/ui/ozone/platform/wayland/ozone_platform_wayland.cc
index a8aa25987772..50c61375472c 100644
--- a/ui/ozone/platform/wayland/ozone_platform_wayland.cc
+++ b/ui/ozone/platform/wayland/ozone_platform_wayland.cc
@@ -115,7 +115,8 @@ class OzonePlatformWayland : public OzonePlatform {
     // The WaylandConnection and the WaylandOutputManager must be created before
     // PlatformScreen.
     DCHECK(connection_ && connection_->wayland_output_manager());
-    return connection_->wayland_output_manager()->CreateWaylandScreen();
+    return connection_->wayland_output_manager()->CreateWaylandScreen(
+        connection_.get());
   }
 
   PlatformClipboard* GetPlatformClipboard() override {
diff --git a/ui/ozone/platform/wayland/wayland_object.h b/ui/ozone/platform/wayland/wayland_object.h
index 34984d3296ac..6e5e1b082458 100644
--- a/ui/ozone/platform/wayland/wayland_object.h
+++ b/ui/ozone/platform/wayland/wayland_object.h
@@ -251,7 +251,7 @@ class Object : public std::unique_ptr<T, Deleter> {
   Object() {}
   explicit Object(T* obj) : std::unique_ptr<T, Deleter>(obj) {}
 
-  uint32_t id() {
+  uint32_t id() const {
     return wl_proxy_get_id(
         reinterpret_cast<wl_proxy*>(std::unique_ptr<T, Deleter>::get()));
   }
diff --git a/ui/ozone/platform/wayland/wayland_output_manager.cc b/ui/ozone/platform/wayland/wayland_output_manager.cc
index c9db25c35b40..8c3b59948970 100644
--- a/ui/ozone/platform/wayland/wayland_output_manager.cc
+++ b/ui/ozone/platform/wayland/wayland_output_manager.cc
@@ -65,8 +65,9 @@ void WaylandOutputManager::RemoveWaylandOutput(const uint32_t output_id) {
   OnWaylandOutputRemoved(output_id);
 }
 
-std::unique_ptr<WaylandScreen> WaylandOutputManager::CreateWaylandScreen() {
-  auto wayland_screen = std::make_unique<WaylandScreen>();
+std::unique_ptr<WaylandScreen> WaylandOutputManager::CreateWaylandScreen(
+    WaylandConnection* connection) {
+  auto wayland_screen = std::make_unique<WaylandScreen>(connection);
   wayland_screen_ = wayland_screen->GetWeakPtr();
 
   // As long as |wl_output| sends geometry and other events asynchronously (that
diff --git a/ui/ozone/platform/wayland/wayland_output_manager.h b/ui/ozone/platform/wayland/wayland_output_manager.h
index 5fcdced8a042..ef429190c990 100644
--- a/ui/ozone/platform/wayland/wayland_output_manager.h
+++ b/ui/ozone/platform/wayland/wayland_output_manager.h
@@ -19,6 +19,7 @@ struct wl_output;
 
 namespace ui {
 
+class WaylandConnection;
 class WaylandOutput;
 
 class WaylandOutputManager : public WaylandOutput::Delegate {
@@ -33,7 +34,8 @@ class WaylandOutputManager : public WaylandOutput::Delegate {
   void RemoveWaylandOutput(const uint32_t output_id);
 
   // Creates a platform screen and feeds it with existing outputs.
-  std::unique_ptr<WaylandScreen> CreateWaylandScreen();
+  std::unique_ptr<WaylandScreen> CreateWaylandScreen(
+      WaylandConnection* connection);
 
  private:
   void OnWaylandOutputAdded(uint32_t output_id);
diff --git a/ui/ozone/platform/wayland/wayland_screen.cc b/ui/ozone/platform/wayland/wayland_screen.cc
index 98ef35e3f614..6906ee44929c 100644
--- a/ui/ozone/platform/wayland/wayland_screen.cc
+++ b/ui/ozone/platform/wayland/wayland_screen.cc
@@ -9,10 +9,15 @@
 #include "ui/display/display_observer.h"
 #include "ui/gfx/geometry/point.h"
 #include "ui/gfx/geometry/size.h"
+#include "ui/ozone/platform/wayland/wayland_connection.h"
+#include "ui/ozone/platform/wayland/wayland_window.h"
 
 namespace ui {
 
-WaylandScreen::WaylandScreen() : weak_factory_(this) {}
+WaylandScreen::WaylandScreen(WaylandConnection* connection)
+    : connection_(connection), weak_factory_(this) {
+  DCHECK(connection_);
+}
 
 WaylandScreen::~WaylandScreen() = default;
 
@@ -75,11 +80,11 @@ gfx::Point WaylandScreen::GetCursorScreenPoint() const {
 
 gfx::AcceleratedWidget WaylandScreen::GetAcceleratedWidgetAtScreenPoint(
     const gfx::Point& point) const {
-  // TODO(msisov): implement this once wl_surface_listener::enter and ::leave
-  // are used.
-  //
-  // https://crbug.com/890271
-  NOTIMPLEMENTED_LOG_ONCE();
+  // It is safe to check only for focused windows and test if they contain the
+  // point or not.
+  auto* window = connection_->GetCurrentFocusedWindow();
+  if (window && window->GetBounds().Contains(point))
+    return window->GetWidget();
   return gfx::kNullAcceleratedWidget;
 }
 
diff --git a/ui/ozone/platform/wayland/wayland_screen.h b/ui/ozone/platform/wayland/wayland_screen.h
index f2de8d4dbb95..fe6f74f26cd3 100644
--- a/ui/ozone/platform/wayland/wayland_screen.h
+++ b/ui/ozone/platform/wayland/wayland_screen.h
@@ -17,10 +17,12 @@
 
 namespace ui {
 
+class WaylandConnection;
+
 // A PlatformScreen implementation for Wayland.
 class WaylandScreen : public PlatformScreen {
  public:
-  WaylandScreen();
+  explicit WaylandScreen(WaylandConnection* connection);
   ~WaylandScreen() override;
 
   void OnOutputAdded(uint32_t output_id, bool is_primary);
@@ -48,6 +50,8 @@ class WaylandScreen : public PlatformScreen {
   void RemoveObserver(display::DisplayObserver* observer) override;
 
  private:
+  WaylandConnection* connection_ = nullptr;
+
   display::DisplayList display_list_;
 
   base::ObserverList<display::DisplayObserver> observers_;
diff --git a/ui/ozone/platform/wayland/wayland_screen_unittest.cc b/ui/ozone/platform/wayland/wayland_screen_unittest.cc
index 7eb9350f2987..ad51723cf5cd 100644
--- a/ui/ozone/platform/wayland/wayland_screen_unittest.cc
+++ b/ui/ozone/platform/wayland/wayland_screen_unittest.cc
@@ -11,6 +11,7 @@
 #include "ui/ozone/platform/wayland/wayland_output_manager.h"
 #include "ui/ozone/platform/wayland/wayland_screen.h"
 #include "ui/ozone/platform/wayland/wayland_test.h"
+#include "ui/platform_window/platform_window_init_properties.h"
 
 namespace ui {
 
@@ -69,12 +70,31 @@ class WaylandScreenTest : public WaylandTest {
 
     output_manager_ = connection_->wayland_output_manager();
     ASSERT_TRUE(output_manager_);
+
+    EXPECT_TRUE(output_manager_->IsPrimaryOutputReady());
+    platform_screen_ = output_manager_->CreateWaylandScreen(connection_.get());
   }
 
  protected:
+  std::unique_ptr<WaylandWindow> CreateWaylandWindowWithProperties(
+      const gfx::Rect& bounds,
+      PlatformWindowType window_type,
+      gfx::AcceleratedWidget parent_widget,
+      MockPlatformWindowDelegate* delegate) {
+    auto window = std::make_unique<WaylandWindow>(delegate, connection_.get());
+    PlatformWindowInitProperties properties;
+    properties.bounds = bounds;
+    properties.type = window_type;
+    properties.parent_widget = parent_widget;
+    EXPECT_TRUE(window->Initialize(std::move(properties)));
+    return window;
+  }
+
   wl::MockOutput* output_ = nullptr;
   WaylandOutputManager* output_manager_ = nullptr;
 
+  std::unique_ptr<WaylandScreen> platform_screen_;
+
  private:
   DISALLOW_COPY_AND_ASSIGN(WaylandScreenTest);
 };
@@ -82,27 +102,21 @@ class WaylandScreenTest : public WaylandTest {
 // Tests whether a primary output has been initialized before PlatformScreen is
 // created.
 TEST_P(WaylandScreenTest, OutputBaseTest) {
-  EXPECT_TRUE(output_manager_->IsPrimaryOutputReady());
-
-  std::unique_ptr<WaylandScreen> platform_screen =
-      output_manager_->CreateWaylandScreen();
+  // IsPrimaryOutputReady and PlatformScreen creation is done in the
+  // initialization part of the tests.
 
   // Ensure there is only one display, which is the primary one.
-  auto& all_displays = platform_screen->GetAllDisplays();
+  auto& all_displays = platform_screen_->GetAllDisplays();
   EXPECT_EQ(all_displays.size(), kNumberOfDisplays);
 
   // Ensure the size property of the primary display.
-  EXPECT_EQ(platform_screen->GetPrimaryDisplay().bounds(),
+  EXPECT_EQ(platform_screen_->GetPrimaryDisplay().bounds(),
             gfx::Rect(0, 0, kOutputWidth, kOutputHeight));
 }
 
 TEST_P(WaylandScreenTest, MultipleOutputsAddedAndRemoved) {
-  EXPECT_TRUE(output_manager_->IsPrimaryOutputReady());
-  std::unique_ptr<WaylandScreen> platform_screen =
-      output_manager_->CreateWaylandScreen();
-
   TestDisplayObserver observer;
-  platform_screen->AddObserver(&observer);
+  platform_screen_->AddObserver(&observer);
 
   // Add a second display.
   server_.CreateAndInitializeOutput();
@@ -111,7 +125,7 @@ TEST_P(WaylandScreenTest, MultipleOutputsAddedAndRemoved) {
 
   // Ensure that second display is not a primary one and have a different id.
   int64_t added_display_id = observer.GetDisplay().id();
-  EXPECT_NE(platform_screen->GetPrimaryDisplay().id(), added_display_id);
+  EXPECT_NE(platform_screen_->GetPrimaryDisplay().id(), added_display_id);
 
   // Remove the second output.
   output_manager_->RemoveWaylandOutput(added_display_id);
@@ -129,25 +143,25 @@ TEST_P(WaylandScreenTest, MultipleOutputsAddedAndRemoved) {
 
   // The newly added display is not a primary yet.
   added_display_id = observer.GetDisplay().id();
-  EXPECT_NE(platform_screen->GetPrimaryDisplay().id(), added_display_id);
+  EXPECT_NE(platform_screen_->GetPrimaryDisplay().id(), added_display_id);
 
   // Make sure the geometry changes are sent by syncing one more time again.
   Sync();
 
-  int64_t old_primary_display_id = platform_screen->GetPrimaryDisplay().id();
+  int64_t old_primary_display_id = platform_screen_->GetPrimaryDisplay().id();
   output_manager_->RemoveWaylandOutput(old_primary_display_id);
 
   // Ensure that previously added display is now a primary one.
-  EXPECT_EQ(platform_screen->GetPrimaryDisplay().id(), added_display_id);
+  EXPECT_EQ(platform_screen_->GetPrimaryDisplay().id(), added_display_id);
   // Ensure that the removed display was the one, which was a primary display.
   EXPECT_EQ(observer.GetDisplay().id(), old_primary_display_id);
+
+  platform_screen_->RemoveObserver(&observer);
 }
 
 TEST_P(WaylandScreenTest, OutputPropertyChanges) {
-  std::unique_ptr<WaylandScreen> platform_screen =
-      output_manager_->CreateWaylandScreen();
   TestDisplayObserver observer;
-  platform_screen->AddObserver(&observer);
+  platform_screen_->AddObserver(&observer);
 
   const gfx::Rect new_rect(0, 0, 800, 600);
   wl_output_send_geometry(output_->resource(), new_rect.x(), new_rect.y(),
@@ -175,6 +189,61 @@ TEST_P(WaylandScreenTest, OutputPropertyChanges) {
       display::DisplayObserver::DISPLAY_METRIC_DEVICE_SCALE_FACTOR;
   EXPECT_EQ(observer.GetAndClearChangedMetrics(), changed_values);
   EXPECT_EQ(observer.GetDisplay().device_scale_factor(), new_scale_value);
+
+  platform_screen_->RemoveObserver(&observer);
+}
+
+TEST_P(WaylandScreenTest, GetAcceleratedWidgetAtScreenPoint) {
+  // If there is no focused window (focus is set whenever a pointer enters any
+  // of the windows), there must be kNullAcceleratedWidget returned. There is no
+  // real way to determine what window is located on a certain screen point in
+  // Wayland.
+  gfx::AcceleratedWidget widget_at_screen_point =
+      platform_screen_->GetAcceleratedWidgetAtScreenPoint(gfx::Point(10, 10));
+  EXPECT_EQ(widget_at_screen_point, gfx::kNullAcceleratedWidget);
+
+  // Set a focus to the main window. Now, that focused window must be returned.
+  window_->set_pointer_focus(true);
+  widget_at_screen_point =
+      platform_screen_->GetAcceleratedWidgetAtScreenPoint(gfx::Point(10, 10));
+  EXPECT_EQ(widget_at_screen_point, window_->GetWidget());
+
+  // Getting a widget at a screen point outside its bounds, must result in a
+  // null widget.
+  const gfx::Rect window_bounds = window_->GetBounds();
+  widget_at_screen_point = platform_screen_->GetAcceleratedWidgetAtScreenPoint(
+      gfx::Point(window_bounds.width() + 1, window_bounds.height() + 1));
+  EXPECT_EQ(widget_at_screen_point, gfx::kNullAcceleratedWidget);
+
+  MockPlatformWindowDelegate delegate;
+  std::unique_ptr<WaylandWindow> menu_window =
+      CreateWaylandWindowWithProperties(
+          gfx::Rect(window_->GetBounds().width() - 10,
+                    window_->GetBounds().height() - 10, 100, 100),
+          PlatformWindowType::kPopup, window_->GetWidget(), &delegate);
+
+  Sync();
+
+  // Imagine the mouse enters a menu window, which is located on top of the main
+  // window, and gathers focus.
+  window_->set_pointer_focus(false);
+  menu_window->set_pointer_focus(true);
+  widget_at_screen_point =
+      platform_screen_->GetAcceleratedWidgetAtScreenPoint(gfx::Point(
+          menu_window->GetBounds().x() + 1, menu_window->GetBounds().y() + 1));
+  EXPECT_EQ(widget_at_screen_point, menu_window->GetWidget());
+
+  // Whenever a mouse pointer leaves the menu window, the accelerated widget
+  // of that focused window must be returned.
+  window_->set_pointer_focus(true);
+  menu_window->set_pointer_focus(false);
+  widget_at_screen_point =
+      platform_screen_->GetAcceleratedWidgetAtScreenPoint(gfx::Point(0, 0));
+  EXPECT_EQ(widget_at_screen_point, window_->GetWidget());
+
+  // Reset the focus to avoid crash on dtor as long as there is no real pointer
+  // object.
+  window_->set_pointer_focus(false);
 }
 
 INSTANTIATE_TEST_CASE_P(XdgVersionV5Test,
diff --git a/ui/ozone/platform/wayland/wayland_window.cc b/ui/ozone/platform/wayland/wayland_window.cc
index 3c3a59001acc..eeb3068c15e4 100644
--- a/ui/ozone/platform/wayland/wayland_window.cc
+++ b/ui/ozone/platform/wayland/wayland_window.cc
@@ -92,7 +92,7 @@ WaylandWindow::~WaylandWindow() {
   }
 
   PlatformEventSource::GetInstance()->RemovePlatformEventDispatcher(this);
-  connection_->RemoveWindow(surface_.id());
+  connection_->RemoveWindow(GetWidget());
 
   if (parent_window_)
     parent_window_->set_child_window(nullptr);
@@ -140,13 +140,19 @@ bool WaylandWindow::Initialize(PlatformWindowInitProperties properties) {
 
   connection_->ScheduleFlush();
 
-  connection_->AddWindow(surface_.id(), this);
+  connection_->AddWindow(GetWidget(), this);
   PlatformEventSource::GetInstance()->AddPlatformEventDispatcher(this);
-  delegate_->OnAcceleratedWidgetAvailable(surface_.id());
+  delegate_->OnAcceleratedWidgetAvailable(GetWidget());
 
   return true;
 }
 
+gfx::AcceleratedWidget WaylandWindow::GetWidget() const {
+  if (!surface_)
+    return gfx::kNullAcceleratedWidget;
+  return surface_.id();
+}
+
 void WaylandWindow::CreateXdgPopup() {
   if (bounds_.IsEmpty())
     return;
diff --git a/ui/ozone/platform/wayland/wayland_window.h b/ui/ozone/platform/wayland/wayland_window.h
index 7e54fb49f115..a3ab6c477048 100644
--- a/ui/ozone/platform/wayland/wayland_window.h
+++ b/ui/ozone/platform/wayland/wayland_window.h
@@ -52,6 +52,8 @@ class WaylandWindow : public PlatformWindow,
   XDGSurfaceWrapper* xdg_surface() const { return xdg_surface_.get(); }
   XDGPopupWrapper* xdg_popup() const { return xdg_popup_.get(); }
 
+  gfx::AcceleratedWidget GetWidget() const;
+
   // Apply the bounds specified in the most recent configure event. This should
   // be called after processing all pending events in the wayland connection.
   void ApplyPendingBounds();
-- 
2.17.1

