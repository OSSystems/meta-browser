Upstream-Status: Backport

Signed-off-by: Maksim Sisov <msisov@igalia.com>
---
From 0830a76b345eb319ae3bc4f6e7881f241dd3f376 Mon Sep 17 00:00:00 2001
From: Maksim Sisov <msisov@igalia.com>
Date: Thu, 4 Apr 2019 06:10:29 +0000
Subject: [PATCH 20/27] [ozone/wayland] Separate swap buffer and presentation
 callbacks

Previously, the WaylandBufferManager did not send swap completion
callbacks before the presentation feedback was available.

This resulted in delays and blocked the display compositor as long
as it was waiting for the swap ack => perf regression.

Thus, split the callbacks and handle them separately.

In the follow up CLs, I will also move the submit frame queue
from the GbmSurfacelessWayland to WaylandBufferManager, which
receives frame callbacks and able to send the pending buffers as
soon as possible. Also, it will use buffer release callbacks, which
may come earlier that frame callbacks.

Bug: 943096
Change-Id: Ia51389b6cbbe736d19cb22e1f6532faf5e0477f4
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1538195
Reviewed-by: Michael Spang <spang@chromium.org>
Reviewed-by: Tom Sepez <tsepez@chromium.org>
Commit-Queue: Maksim Sisov <msisov@igalia.com>
Cr-Commit-Position: refs/heads/master@{#647629}
---
 .../platform/wayland/common/wayland_util.h    |   6 -
 .../wayland/gpu/gbm_pixmap_wayland.cc         |   9 +-
 .../platform/wayland/gpu/gbm_pixmap_wayland.h |  10 +-
 .../wayland/gpu/gbm_surfaceless_wayland.cc    |  64 ++++-----
 .../wayland/gpu/gbm_surfaceless_wayland.h     |  21 +--
 .../wayland/gpu/wayland_connection_proxy.cc   |  79 ++++++++---
 .../wayland/gpu/wayland_connection_proxy.h    |  43 ++++--
 .../wayland/gpu/wayland_surface_factory.cc    |  33 +++--
 .../wayland/gpu/wayland_surface_factory.h     |  12 +-
 .../gpu/wayland_surface_factory_unittest.cc   |   4 +-
 .../wayland/host/wayland_buffer_manager.cc    | 126 +++++++++---------
 .../wayland/host/wayland_buffer_manager.h     |  28 ++--
 .../wayland/host/wayland_connection.cc        |  35 +++--
 .../wayland/host/wayland_connection.h         |  24 +++-
 .../wayland/ozone_platform_wayland.cc         |   6 +-
 .../platform/wayland/test/wayland_test.cc     |   3 +-
 .../wayland/wayland_connection.mojom          |  17 ++-
 17 files changed, 321 insertions(+), 199 deletions(-)

diff --git a/ui/ozone/platform/wayland/common/wayland_util.h b/ui/ozone/platform/wayland/common/wayland_util.h
index a6cbdd968a6f..739229f563aa 100644
--- a/ui/ozone/platform/wayland/common/wayland_util.h
+++ b/ui/ozone/platform/wayland/common/wayland_util.h
@@ -20,16 +20,10 @@ class WaylandShmBuffer;
 
 namespace gfx {
 class Size;
-enum class SwapResult;
-struct PresentationFeedback;
 }  // namespace gfx
 
 namespace wl {
 
-// Corresponds to mojom::WaylandConnection::ScheduleBufferSwapCallback.
-using BufferSwapCallback =
-    base::OnceCallback<void(gfx::SwapResult, const gfx::PresentationFeedback&)>;
-
 using RequestSizeCallback = base::OnceCallback<void(const gfx::Size&)>;
 
 using OnRequestBufferCallback =
diff --git a/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.cc b/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.cc
index a8a706819cb1..c9c63c3fed31 100644
--- a/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.cc
+++ b/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.cc
@@ -28,12 +28,15 @@
 namespace ui {
 
 GbmPixmapWayland::GbmPixmapWayland(WaylandSurfaceFactory* surface_manager,
-                                   WaylandConnectionProxy* connection)
-    : surface_manager_(surface_manager), connection_(connection) {}
+                                   WaylandConnectionProxy* connection,
+                                   gfx::AcceleratedWidget widget)
+    : surface_manager_(surface_manager),
+      connection_(connection),
+      widget_(widget) {}
 
 GbmPixmapWayland::~GbmPixmapWayland() {
   if (gbm_bo_)
-    connection_->DestroyZwpLinuxDmabuf(GetUniqueId());
+    connection_->DestroyZwpLinuxDmabuf(widget_, GetUniqueId());
 }
 
 bool GbmPixmapWayland::InitializeBuffer(gfx::Size size,
diff --git a/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.h b/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.h
index 3f43538be354..b99a36d444dc 100644
--- a/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.h
+++ b/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.h
@@ -23,7 +23,8 @@ class WaylandConnectionProxy;
 class GbmPixmapWayland : public gfx::NativePixmap {
  public:
   GbmPixmapWayland(WaylandSurfaceFactory* surface_manager,
-                   WaylandConnectionProxy* connection);
+                   WaylandConnectionProxy* connection,
+                   gfx::AcceleratedWidget widget);
 
   // Creates a buffer object and initializes the pixmap buffer.
   bool InitializeBuffer(gfx::Size size,
@@ -57,10 +58,13 @@ class GbmPixmapWayland : public gfx::NativePixmap {
   // gbm_bo wrapper for struct gbm_bo.
   std::unique_ptr<GbmBuffer> gbm_bo_;
 
-  WaylandSurfaceFactory* surface_manager_ = nullptr;
+  WaylandSurfaceFactory* const surface_manager_;
 
   // Represents a connection to Wayland.
-  WaylandConnectionProxy* connection_ = nullptr;
+  WaylandConnectionProxy* const connection_;
+
+  // Represents widget this pixmap backs.
+  const gfx::AcceleratedWidget widget_;
 
   DISALLOW_COPY_AND_ASSIGN(GbmPixmapWayland);
 };
diff --git a/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.cc b/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.cc
index bbc492642e66..2d2cc50f075a 100644
--- a/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.cc
+++ b/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.cc
@@ -11,6 +11,7 @@
 #include "base/trace_event/trace_event.h"
 #include "ui/gfx/gpu_fence.h"
 #include "ui/ozone/common/egl_util.h"
+#include "ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h"
 #include "ui/ozone/platform/wayland/gpu/wayland_surface_factory.h"
 
 namespace ui {
@@ -27,9 +28,11 @@ void WaitForFence(EGLDisplay display, EGLSyncKHR fence) {
 
 GbmSurfacelessWayland::GbmSurfacelessWayland(
     WaylandSurfaceFactory* surface_factory,
+    WaylandConnectionProxy* connection,
     gfx::AcceleratedWidget widget)
     : SurfacelessEGL(gfx::Size()),
       surface_factory_(surface_factory),
+      connection_(connection),
       widget_(widget),
       has_implicit_external_sync_(
           HasEGLExtension("EGL_ARM_implicit_external_sync")),
@@ -200,18 +203,23 @@ void GbmSurfacelessWayland::SubmitFrame() {
         submitted_frame_->ScheduleOverlayPlanes(widget_);
 
     if (!schedule_planes_succeeded) {
-      OnSubmission(gfx::SwapResult::SWAP_FAILED, nullptr);
-      OnPresentation(gfx::PresentationFeedback::Failure());
+      last_swap_buffers_result_ = false;
+
+      std::move(submitted_frame_->completion_callback)
+          .Run(gfx::SwapResult::SWAP_FAILED, nullptr);
+      // Notify the caller, the buffer is never presented on a screen.
+      std::move(submitted_frame_->presentation_callback)
+          .Run(gfx::PresentationFeedback::Failure());
+
+      submitted_frame_.reset();
       return;
     }
 
-    auto callback =
-        base::BindOnce(&GbmSurfacelessWayland::OnScheduleBufferSwapDone,
-                       weak_factory_.GetWeakPtr());
-    uint32_t buffer_id = planes_.back().pixmap->GetUniqueId();
-    surface_factory_->ScheduleBufferSwap(widget_, buffer_id,
-                                         submitted_frame_->damage_region_,
-                                         std::move(callback));
+    submitted_frame_->buffer_id = planes_.back().pixmap->GetUniqueId();
+    connection_->ScheduleBufferSwap(widget_, submitted_frame_->buffer_id,
+                                    submitted_frame_->damage_region_);
+
+    planes_.clear();
   }
 }
 
@@ -228,31 +236,16 @@ void GbmSurfacelessWayland::FenceRetired(PendingFrame* frame) {
   SubmitFrame();
 }
 
-void GbmSurfacelessWayland::OnScheduleBufferSwapDone(
-    gfx::SwapResult result,
-    const gfx::PresentationFeedback& feedback) {
-  OnSubmission(result, nullptr);
-  OnPresentation(feedback);
-  planes_.clear();
-}
-
-void GbmSurfacelessWayland::OnSubmission(
-    gfx::SwapResult result,
-    std::unique_ptr<gfx::GpuFence> out_fence) {
-  submitted_frame_->swap_result = result;
-}
-
-void GbmSurfacelessWayland::OnPresentation(
-    const gfx::PresentationFeedback& feedback) {
-  // Explicitly destroy overlays to free resources (e.g., fences) early.
+void GbmSurfacelessWayland::OnSubmission(uint32_t buffer_id,
+                                         const gfx::SwapResult& swap_result) {
   submitted_frame_->overlays.clear();
 
-  gfx::SwapResult result = submitted_frame_->swap_result;
-  std::move(submitted_frame_->completion_callback).Run(result, nullptr);
-  std::move(submitted_frame_->presentation_callback).Run(feedback);
-  submitted_frame_.reset();
+  DCHECK_EQ(submitted_frame_->buffer_id, buffer_id);
+  std::move(submitted_frame_->completion_callback).Run(swap_result, nullptr);
 
-  if (result == gfx::SwapResult::SWAP_FAILED) {
+  pending_presentation_frames_.push_back(std::move(submitted_frame_));
+
+  if (swap_result != gfx::SwapResult::SWAP_ACK) {
     last_swap_buffers_result_ = false;
     return;
   }
@@ -260,4 +253,13 @@ void GbmSurfacelessWayland::OnPresentation(
   SubmitFrame();
 }
 
+void GbmSurfacelessWayland::OnPresentation(
+    uint32_t buffer_id,
+    const gfx::PresentationFeedback& feedback) {
+  auto* frame = pending_presentation_frames_.front().get();
+  DCHECK_EQ(frame->buffer_id, buffer_id);
+  std::move(frame->presentation_callback).Run(feedback);
+  pending_presentation_frames_.erase(pending_presentation_frames_.begin());
+}
+
 }  // namespace ui
diff --git a/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.h b/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.h
index f86dd4b0c9c6..dfd3d91fb731 100644
--- a/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.h
+++ b/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.h
@@ -16,6 +16,7 @@
 
 namespace ui {
 
+class WaylandConnectionProxy;
 class WaylandSurfaceFactory;
 
 // A GLSurface for Wayland Ozone platform that uses surfaceless drawing. Drawing
@@ -25,6 +26,7 @@ class WaylandSurfaceFactory;
 class GbmSurfacelessWayland : public gl::SurfacelessEGL {
  public:
   GbmSurfacelessWayland(WaylandSurfaceFactory* surface_factory,
+                        WaylandConnectionProxy* connection,
                         gfx::AcceleratedWidget widget);
 
   void QueueOverlayPlane(OverlayPlane plane);
@@ -57,6 +59,10 @@ class GbmSurfacelessWayland : public gl::SurfacelessEGL {
   EGLConfig GetConfig() override;
   void SetRelyOnImplicitSync() override;
 
+  void OnSubmission(uint32_t buffer_id, const gfx::SwapResult& swap_result);
+  void OnPresentation(uint32_t buffer_id,
+                      const gfx::PresentationFeedback& feedback);
+
  private:
   ~GbmSurfacelessWayland() override;
 
@@ -68,7 +74,10 @@ class GbmSurfacelessWayland : public gl::SurfacelessEGL {
     void Flush();
 
     bool ready = false;
-    gfx::SwapResult swap_result = gfx::SwapResult::SWAP_FAILED;
+
+    // The id of the buffer, which represents this frame.
+    uint32_t buffer_id = 0;
+
     // A region of the updated content in a corresponding frame. It's used to
     // advice Wayland which part of a buffer is going to be updated. Passing {0,
     // 0, 0, 0} results in a whole buffer update on the Wayland compositor side.
@@ -83,18 +92,14 @@ class GbmSurfacelessWayland : public gl::SurfacelessEGL {
   EGLSyncKHR InsertFence(bool implicit);
   void FenceRetired(PendingFrame* frame);
 
-  void OnScheduleBufferSwapDone(gfx::SwapResult result,
-                                const gfx::PresentationFeedback& feedback);
-  void OnSubmission(gfx::SwapResult result,
-                    std::unique_ptr<gfx::GpuFence> out_fence);
-  void OnPresentation(const gfx::PresentationFeedback& feedback);
-
-  WaylandSurfaceFactory* surface_factory_;
+  WaylandSurfaceFactory* const surface_factory_;
+  WaylandConnectionProxy* const connection_;
   std::vector<OverlayPlane> planes_;
 
   // The native surface. Deleting this is allowed to free the EGLNativeWindow.
   gfx::AcceleratedWidget widget_;
   std::vector<std::unique_ptr<PendingFrame>> unsubmitted_frames_;
+  std::vector<std::unique_ptr<PendingFrame>> pending_presentation_frames_;
   std::unique_ptr<PendingFrame> submitted_frame_;
   bool has_implicit_external_sync_;
   bool last_swap_buffers_result_ = true;
diff --git a/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.cc b/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.cc
index d9ed612b9f73..ca84e0da7672 100644
--- a/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.cc
+++ b/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.cc
@@ -8,14 +8,20 @@
 
 #include "base/bind.h"
 #include "base/process/process.h"
+#include "mojo/public/cpp/bindings/associated_interface_ptr.h"
 #include "third_party/khronos/EGL/egl.h"
 #include "ui/ozone/common/linux/drm_util_linux.h"
+#include "ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.h"
+#include "ui/ozone/platform/wayland/gpu/wayland_surface_factory.h"
 #include "ui/ozone/platform/wayland/host/wayland_connection.h"
 
 namespace ui {
 
-WaylandConnectionProxy::WaylandConnectionProxy(WaylandConnection* connection)
+WaylandConnectionProxy::WaylandConnectionProxy(WaylandConnection* connection,
+                                               WaylandSurfaceFactory* factory)
     : connection_(connection),
+      factory_(factory),
+      associated_binding_(this),
       gpu_thread_runner_(base::ThreadTaskRunnerHandle::Get()) {}
 
 WaylandConnectionProxy::~WaylandConnectionProxy() = default;
@@ -35,6 +41,33 @@ void WaylandConnectionProxy::ResetGbmDevice() {
 #endif
 }
 
+void WaylandConnectionProxy::OnSubmission(gfx::AcceleratedWidget widget,
+                                          uint32_t buffer_id,
+                                          gfx::SwapResult swap_result) {
+  DCHECK(gpu_thread_runner_->BelongsToCurrentThread());
+  DCHECK_NE(widget, gfx::kNullAcceleratedWidget);
+  auto* surface = factory_->GetSurface(widget);
+  // There can be a race between destruction and submitting the last frames. The
+  // surface can be destroyed by the time the host receives a request to destroy
+  // a buffer, and is able to call the OnSubmission for that specific buffer.
+  if (surface)
+    surface->OnSubmission(buffer_id, swap_result);
+}
+
+void WaylandConnectionProxy::OnPresentation(
+    gfx::AcceleratedWidget widget,
+    uint32_t buffer_id,
+    const gfx::PresentationFeedback& feedback) {
+  DCHECK(gpu_thread_runner_->BelongsToCurrentThread());
+  DCHECK_NE(widget, gfx::kNullAcceleratedWidget);
+  auto* surface = factory_->GetSurface(widget);
+  // There can be a race between destruction and presenting the last frames. The
+  // surface can be destroyed by the time the host receives a request to destroy
+  // a buffer, and is able to call the OnPresentation for that specific buffer.
+  if (surface)
+    surface->OnPresentation(buffer_id, feedback);
+}
+
 void WaylandConnectionProxy::CreateZwpLinuxDmabuf(
     base::File file,
     gfx::Size size,
@@ -69,10 +102,9 @@ void WaylandConnectionProxy::CreateZwpLinuxDmabufInternal(
   // from the thread, which is used to call these methods. Thus, rebind the
   // interface on a first call to ensure mojo calls will always happen on a
   // sequence we want.
-  if (!bound_) {
-    wc_ptr_.Bind(std::move(wc_ptr_info_));
-    bound_ = true;
-  }
+  if (!wc_ptr_.is_bound())
+    BindHostInterface();
+
   DCHECK(gpu_thread_runner_->BelongsToCurrentThread());
   DCHECK(wc_ptr_);
   wc_ptr_->CreateZwpLinuxDmabuf(std::move(file), size.width(), size.height(),
@@ -80,31 +112,36 @@ void WaylandConnectionProxy::CreateZwpLinuxDmabufInternal(
                                 planes_count, buffer_id);
 }
 
-void WaylandConnectionProxy::DestroyZwpLinuxDmabuf(uint32_t buffer_id) {
+void WaylandConnectionProxy::DestroyZwpLinuxDmabuf(
+    gfx::AcceleratedWidget widget,
+    uint32_t buffer_id) {
   DCHECK(gpu_thread_runner_);
+
   // Do a mojo call on the GpuMainThread instead of the io child thread to
   // ensure proper functionality.
   gpu_thread_runner_->PostTask(
       FROM_HERE,
       base::BindOnce(&WaylandConnectionProxy::DestroyZwpLinuxDmabufInternal,
-                     base::Unretained(this), buffer_id));
+                     base::Unretained(this), widget, buffer_id));
 }
 
-void WaylandConnectionProxy::DestroyZwpLinuxDmabufInternal(uint32_t buffer_id) {
+void WaylandConnectionProxy::DestroyZwpLinuxDmabufInternal(
+    gfx::AcceleratedWidget widget,
+    uint32_t buffer_id) {
   DCHECK(gpu_thread_runner_->BelongsToCurrentThread());
   DCHECK(wc_ptr_);
+
   wc_ptr_->DestroyZwpLinuxDmabuf(buffer_id);
 }
 
 void WaylandConnectionProxy::ScheduleBufferSwap(
     gfx::AcceleratedWidget widget,
     uint32_t buffer_id,
-    const gfx::Rect& damage_region,
-    wl::BufferSwapCallback callback) {
+    const gfx::Rect& damage_region) {
   DCHECK(gpu_thread_runner_->BelongsToCurrentThread());
   DCHECK(wc_ptr_);
-  wc_ptr_->ScheduleBufferSwap(widget, buffer_id, damage_region,
-                              std::move(callback));
+
+  wc_ptr_->ScheduleBufferSwap(widget, buffer_id, damage_region);
 }
 
 void WaylandConnectionProxy::CreateShmBufferForWidget(
@@ -112,10 +149,9 @@ void WaylandConnectionProxy::CreateShmBufferForWidget(
     base::File file,
     size_t length,
     const gfx::Size size) {
-  if (!bound_) {
-    wc_ptr_.Bind(std::move(wc_ptr_info_));
-    bound_ = true;
-  }
+  if (!wc_ptr_.is_bound())
+    BindHostInterface();
+
   DCHECK(wc_ptr_);
   wc_ptr_->CreateShmBufferForWidget(widget, std::move(file), length, size);
 }
@@ -163,4 +199,15 @@ void WaylandConnectionProxy::AddBindingWaylandConnectionClient(
   bindings_.AddBinding(this, std::move(request));
 }
 
+void WaylandConnectionProxy::BindHostInterface() {
+  DCHECK(!wc_ptr_.is_bound());
+  wc_ptr_.Bind(std::move(wc_ptr_info_));
+
+  // Setup associated interface.
+  ozone::mojom::WaylandConnectionClientAssociatedPtrInfo client_ptr_info;
+  auto request = MakeRequest(&client_ptr_info);
+  wc_ptr_->SetWaylandConnectionClient(std::move(client_ptr_info));
+  associated_binding_.Bind(std::move(request));
+}
+
 }  // namespace ui
diff --git a/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h b/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h
index 9ac154263463..6b97559eb81b 100644
--- a/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h
+++ b/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h
@@ -10,8 +10,10 @@
 #include "base/macros.h"
 #include "base/threading/sequenced_task_runner_handle.h"
 #include "base/threading/thread_checker.h"
+#include "mojo/public/cpp/bindings/associated_binding.h"
 #include "mojo/public/cpp/bindings/binding_set.h"
 #include "ui/gfx/native_widget_types.h"
+#include "ui/gl/gl_surface.h"
 #include "ui/ozone/platform/wayland/common/wayland_util.h"
 #include "ui/ozone/platform/wayland/host/wayland_connection.h"
 #include "ui/ozone/public/interfaces/wayland/wayland_connection.mojom.h"
@@ -28,6 +30,7 @@ class Rect;
 namespace ui {
 
 class WaylandConnection;
+class WaylandSurfaceFactory;
 class WaylandWindow;
 
 // Provides a proxy connection to a WaylandConnection object on
@@ -39,12 +42,22 @@ class WaylandWindow;
 // sequence.
 class WaylandConnectionProxy : public ozone::mojom::WaylandConnectionClient {
  public:
-  explicit WaylandConnectionProxy(WaylandConnection* connection);
+  WaylandConnectionProxy(WaylandConnection* connection,
+                         WaylandSurfaceFactory* factory);
   ~WaylandConnectionProxy() override;
 
   // WaylandConnectionProxy overrides:
   void SetWaylandConnection(ozone::mojom::WaylandConnectionPtr wc_ptr) override;
   void ResetGbmDevice() override;
+  // These two calls get the surface, which backs the |widget| and notifies it
+  // about the submission and the presentation. After the surface receives the
+  // OnSubmission call, it can schedule a new buffer for swap.
+  void OnSubmission(gfx::AcceleratedWidget widget,
+                    uint32_t buffer_id,
+                    gfx::SwapResult swap_result) override;
+  void OnPresentation(gfx::AcceleratedWidget widget,
+                      uint32_t buffer_id,
+                      const gfx::PresentationFeedback& feedback) override;
 
   // Methods, which must be used when GPU is hosted on a different process
   // aka gpu process.
@@ -61,16 +74,21 @@ class WaylandConnectionProxy : public ozone::mojom::WaylandConnectionClient {
                             uint32_t buffer_id);
 
   // Asks Wayland to destroy a wl_buffer.
-  void DestroyZwpLinuxDmabuf(uint32_t buffer_id);
+  void DestroyZwpLinuxDmabuf(gfx::AcceleratedWidget widget, uint32_t buffer_id);
 
   // Asks Wayland to find a wl_buffer with the |buffer_id| and schedule a
   // buffer swap for a WaylandWindow, which backs the following |widget|.
-  // The |callback| is called once a frame callback from the Wayland server
-  // is received.
+  // Once the buffer is submitted and presented, the OnSubmission and
+  // OnPresentation are called. Note, it's not guaranteed the OnPresentation
+  // will follow the OnSubmission immediately, but the OnPresentation must never
+  // be called before the OnSubmission is called for that particular buffer.
+  // This logic must be checked by the client, though the host ensures this
+  // logic as well. This call must not be done twice for the same |widget| until
+  // the OnSubmission is called (which actually means the client can continue
+  // sending buffer swap requests).
   void ScheduleBufferSwap(gfx::AcceleratedWidget widget,
                           uint32_t buffer_id,
-                          const gfx::Rect& damage_region,
-                          wl::BufferSwapCallback callback);
+                          const gfx::Rect& damage_region);
 
 #if defined(WAYLAND_GBM)
   // Returns a gbm_device based on a DRM render node.
@@ -127,12 +145,19 @@ class WaylandConnectionProxy : public ozone::mojom::WaylandConnectionClient {
                                     uint32_t current_format,
                                     uint32_t planes_count,
                                     uint32_t buffer_id);
-  void DestroyZwpLinuxDmabufInternal(uint32_t buffer_id);
+  void DestroyZwpLinuxDmabufInternal(gfx::AcceleratedWidget widget,
+                                     uint32_t buffer_id);
+
+  void BindHostInterface();
 
   // Non-owned pointer to a WaylandConnection. It is only used in a single
   // process mode, when a shared dmabuf approach is not used.
   WaylandConnection* const connection_;
 
+  // Non-owned. Only used to get registered surfaces and notify them about
+  // submission and presentation of buffers.
+  WaylandSurfaceFactory* const factory_;
+
 #if defined(WAYLAND_GBM)
   // A DRM render node based gbm device.
   std::unique_ptr<GbmDevice> gbm_device_;
@@ -144,7 +169,9 @@ class WaylandConnectionProxy : public ozone::mojom::WaylandConnectionClient {
   // process side. It's used for a multi-process mode.
   ozone::mojom::WaylandConnectionPtr wc_ptr_;
   ozone::mojom::WaylandConnectionPtrInfo wc_ptr_info_;
-  bool bound_ = false;
+
+  mojo::AssociatedBinding<ozone::mojom::WaylandConnectionClient>
+      associated_binding_;
 
   // A task runner, which is initialized in a multi-process mode. It is used to
   // ensure all the methods of this class are run on GpuMainThread. This is
diff --git a/ui/ozone/platform/wayland/gpu/wayland_surface_factory.cc b/ui/ozone/platform/wayland/gpu/wayland_surface_factory.cc
index 7ecee5c76789..1bd377af7679 100644
--- a/ui/ozone/platform/wayland/gpu/wayland_surface_factory.cc
+++ b/ui/ozone/platform/wayland/gpu/wayland_surface_factory.cc
@@ -84,7 +84,8 @@ scoped_refptr<gl::GLSurface> GLOzoneEGLWayland::CreateSurfacelessViewGLSurface(
   // If there is a gbm device available, use surfaceless gl surface.
   if (!connection_->gbm_device())
     return nullptr;
-  return gl::InitializeGLSurface(new GbmSurfacelessWayland(factory_, window));
+  return gl::InitializeGLSurface(
+      new GbmSurfacelessWayland(factory_, connection_, window));
 #else
   return nullptr;
 #endif
@@ -113,15 +114,17 @@ bool GLOzoneEGLWayland::LoadGLES2Bindings(gl::GLImplementation impl) {
 
 }  // namespace
 
-WaylandSurfaceFactory::WaylandSurfaceFactory(WaylandConnectionProxy* connection)
-    : connection_(connection) {
-  if (connection_)
-    egl_implementation_ =
-        std::make_unique<GLOzoneEGLWayland>(connection_, this);
-}
+WaylandSurfaceFactory::WaylandSurfaceFactory() {}
 
 WaylandSurfaceFactory::~WaylandSurfaceFactory() {}
 
+void WaylandSurfaceFactory::SetProxy(WaylandConnectionProxy* proxy) {
+  DCHECK(!connection_ && proxy);
+  connection_ = proxy;
+
+  egl_implementation_ = std::make_unique<GLOzoneEGLWayland>(connection_, this);
+}
+
 void WaylandSurfaceFactory::RegisterSurface(gfx::AcceleratedWidget widget,
                                             GbmSurfacelessWayland* surface) {
   widget_to_surface_map_.insert(std::make_pair(widget, surface));
@@ -133,19 +136,13 @@ void WaylandSurfaceFactory::UnregisterSurface(gfx::AcceleratedWidget widget) {
 
 GbmSurfacelessWayland* WaylandSurfaceFactory::GetSurface(
     gfx::AcceleratedWidget widget) const {
+  GbmSurfacelessWayland* surface = nullptr;
   auto it = widget_to_surface_map_.find(widget);
-  DCHECK(it != widget_to_surface_map_.end());
-  return it->second;
+  if (it != widget_to_surface_map_.end())
+    surface = it->second;
+  return surface;
 }
 
-void WaylandSurfaceFactory::ScheduleBufferSwap(
-    gfx::AcceleratedWidget widget,
-    uint32_t buffer_id,
-    const gfx::Rect& damage_region,
-    wl::BufferSwapCallback callback) {
-  connection_->ScheduleBufferSwap(widget, buffer_id, damage_region,
-                                  std::move(callback));
-}
 
 std::unique_ptr<SurfaceOzoneCanvas>
 WaylandSurfaceFactory::CreateCanvasForWidget(gfx::AcceleratedWidget widget) {
@@ -180,7 +177,7 @@ scoped_refptr<gfx::NativePixmap> WaylandSurfaceFactory::CreateNativePixmap(
     gfx::BufferUsage usage) {
 #if defined(WAYLAND_GBM)
   scoped_refptr<GbmPixmapWayland> pixmap =
-      base::MakeRefCounted<GbmPixmapWayland>(this, connection_);
+      base::MakeRefCounted<GbmPixmapWayland>(this, connection_, widget);
   if (!pixmap->InitializeBuffer(size, format, usage))
     return nullptr;
   return pixmap;
diff --git a/ui/ozone/platform/wayland/gpu/wayland_surface_factory.h b/ui/ozone/platform/wayland/gpu/wayland_surface_factory.h
index 2ebcda09fbab..b85b9ec75a02 100644
--- a/ui/ozone/platform/wayland/gpu/wayland_surface_factory.h
+++ b/ui/ozone/platform/wayland/gpu/wayland_surface_factory.h
@@ -15,10 +15,6 @@
 #include "ui/ozone/platform/wayland/common/wayland_util.h"
 #include "ui/ozone/public/surface_factory_ozone.h"
 
-namespace gfx {
-class Rect;
-}  // namespace gfx
-
 namespace ui {
 
 class GbmSurfacelessWayland;
@@ -26,14 +22,12 @@ class WaylandConnectionProxy;
 
 class WaylandSurfaceFactory : public SurfaceFactoryOzone {
  public:
-  explicit WaylandSurfaceFactory(WaylandConnectionProxy* connection);
+  WaylandSurfaceFactory();
   ~WaylandSurfaceFactory() override;
 
+  void SetProxy(WaylandConnectionProxy* proxy);
+
   // These methods are used, when a dmabuf based approach is used.
-  void ScheduleBufferSwap(gfx::AcceleratedWidget widget,
-                          uint32_t buffer_id,
-                          const gfx::Rect& damage_region_,
-                          wl::BufferSwapCallback callback);
   void RegisterSurface(gfx::AcceleratedWidget widget,
                        GbmSurfacelessWayland* surface);
   void UnregisterSurface(gfx::AcceleratedWidget widget);
diff --git a/ui/ozone/platform/wayland/gpu/wayland_surface_factory_unittest.cc b/ui/ozone/platform/wayland/gpu/wayland_surface_factory_unittest.cc
index ba9de5efeeab..d452e300f13e 100644
--- a/ui/ozone/platform/wayland/gpu/wayland_surface_factory_unittest.cc
+++ b/ui/ozone/platform/wayland/gpu/wayland_surface_factory_unittest.cc
@@ -90,7 +90,9 @@ class FakeGbmDevice : public GbmDevice {
 
 class WaylandSurfaceFactoryTest : public WaylandTest {
  public:
-  WaylandSurfaceFactoryTest() : surface_factory_(connection_proxy_.get()) {}
+  WaylandSurfaceFactoryTest() {
+    surface_factory_.SetProxy(connection_proxy_.get());
+  }
 
   ~WaylandSurfaceFactoryTest() override {}
 
diff --git a/ui/ozone/platform/wayland/host/wayland_buffer_manager.cc b/ui/ozone/platform/wayland/host/wayland_buffer_manager.cc
index 80e06d8b5af2..f44d61d9d599 100644
--- a/ui/ozone/platform/wayland/host/wayland_buffer_manager.cc
+++ b/ui/ozone/platform/wayland/host/wayland_buffer_manager.cc
@@ -42,9 +42,9 @@ base::TimeTicks GetPresentationFeedbackTimeStamp(uint32_t tv_sec_hi,
 
 }  // namespace
 
-WaylandBufferManager::Buffer::Buffer() = default;
-WaylandBufferManager::Buffer::Buffer(const gfx::Size& buffer_size)
-    : size(buffer_size) {}
+WaylandBufferManager::Buffer::Buffer(const gfx::Size& buffer_size,
+                                     uint32_t buffer_id)
+    : size(buffer_size), buffer_id(buffer_id) {}
 WaylandBufferManager::Buffer::~Buffer() = default;
 
 WaylandBufferManager::WaylandBufferManager(WaylandConnection* connection)
@@ -75,7 +75,7 @@ bool WaylandBufferManager::CreateBuffer(base::File file,
   }
 
   std::unique_ptr<Buffer> buffer =
-      std::make_unique<Buffer>(gfx::Size(width, height));
+      std::make_unique<Buffer>(gfx::Size(width, height), buffer_id);
   buffers_.insert(std::make_pair(buffer_id, std::move(buffer)));
 
   auto callback = base::BindOnce(&WaylandBufferManager::OnCreateBufferComplete,
@@ -86,12 +86,10 @@ bool WaylandBufferManager::CreateBuffer(base::File file,
   return true;
 }
 
-// TODO(msisov): handle buffer swap failure or success.
 bool WaylandBufferManager::ScheduleBufferSwap(gfx::AcceleratedWidget widget,
                                               uint32_t buffer_id,
-                                              const gfx::Rect& damage_region,
-                                              wl::BufferSwapCallback callback) {
-  TRACE_EVENT1("wayland", "WaylandBufferManager::ScheduleBufferSwap",
+                                              const gfx::Rect& damage_region) {
+  TRACE_EVENT1("wayland", "WaylandBufferManager::ScheduleSwapBuffer",
                "Buffer id", buffer_id);
 
   if (!ValidateDataFromGpu(widget, buffer_id))
@@ -106,11 +104,11 @@ bool WaylandBufferManager::ScheduleBufferSwap(gfx::AcceleratedWidget widget,
 
   Buffer* buffer = it->second.get();
   DCHECK(buffer);
+  DCHECK(!buffer->swapped && !buffer->presented);
 
   // Assign a widget to this buffer, which is used to find a corresponding
   // WaylandWindow.
   buffer->widget = widget;
-  buffer->buffer_swap_callback = std::move(callback);
   buffer->damage_region = damage_region;
 
   if (buffer->wl_buffer) {
@@ -130,15 +128,7 @@ bool WaylandBufferManager::DestroyBuffer(uint32_t buffer_id) {
     error_message_ = "Trying to destroy non-existing buffer";
     return false;
   }
-  // It can happen that a buffer is destroyed before a frame callback comes.
-  // Thus, just mark this as a successful swap, which is ok to do.
-  Buffer* buffer = it->second.get();
-  if (!buffer->buffer_swap_callback.is_null()) {
-    std::move(buffer->buffer_swap_callback)
-        .Run(gfx::SwapResult::SWAP_ACK,
-             gfx::PresentationFeedback(base::TimeTicks::Now(),
-                                       base::TimeDelta(), 0));
-  }
+
   buffers_.erase(it);
 
   connection_->ScheduleFlush();
@@ -283,10 +273,47 @@ void WaylandBufferManager::OnCreateBufferComplete(
     SwapBuffer(buffer);
 }
 
-void WaylandBufferManager::OnBufferSwapped(Buffer* buffer) {
-  DCHECK(!buffer->buffer_swap_callback.is_null());
-  std::move(buffer->buffer_swap_callback)
-      .Run(buffer->swap_result, std::move(buffer->feedback));
+void WaylandBufferManager::OnSubmission(Buffer* buffer,
+                                        const gfx::SwapResult& swap_result) {
+  DCHECK(!buffer->swapped);
+
+  buffer->wl_frame_callback.reset();
+  buffer->swapped = true;
+  connection_->OnSubmission(buffer->widget, buffer->buffer_id,
+                            gfx::SwapResult::SWAP_ACK);
+
+  // If presentation feedback is not supported, use a fake feedback.
+  if (!connection_->presentation()) {
+    DCHECK(!buffer->wp_presentation_feedback && !buffer->presented);
+    OnPresentation(buffer, gfx::PresentationFeedback(base::TimeTicks::Now(),
+                                                     base::TimeDelta(), 0));
+  } else if (buffer->presented) {
+    DCHECK(!buffer->wp_presentation_feedback);
+    // If the buffer has been presented before the frame callback aka
+    // completion callback (in the future, release callback is going to be
+    // used), present the feedback to the GPU.
+    OnPresentation(buffer, buffer->feedback);
+  } else {
+    DCHECK(buffer->wp_presentation_feedback);
+  }
+}
+
+void WaylandBufferManager::OnPresentation(
+    Buffer* buffer,
+    const gfx::PresentationFeedback& feedback) {
+  buffer->presented = true;
+  buffer->feedback = feedback;
+
+  // If buffer has already been swapped, we can safely notify about the
+  // presentation as well.
+  if (buffer->swapped) {
+    connection_->OnPresentation(buffer->widget, buffer->buffer_id,
+                                buffer->feedback);
+
+    // Reset the status so that DCHECK passes in ::ScheduleBufferSwap call.
+    buffer->presented = false;
+    buffer->swapped = false;
+  }
 }
 
 // static
@@ -295,27 +322,15 @@ void WaylandBufferManager::FrameCallbackDone(void* data,
                                              uint32_t time) {
   WaylandBufferManager* self = static_cast<WaylandBufferManager*>(data);
   DCHECK(self);
+
   for (auto& item : self->buffers_) {
     Buffer* buffer = item.second.get();
     if (buffer->wl_frame_callback.get() == callback) {
-      buffer->swap_result = gfx::SwapResult::SWAP_ACK;
       buffer->wl_frame_callback.reset();
-
-      // If presentation feedback is not supported, use a fake feedback
-      if (!self->connection_->presentation()) {
-        buffer->feedback = gfx::PresentationFeedback(base::TimeTicks::Now(),
-                                                     base::TimeDelta(), 0);
-      }
-      // If presentation feedback event either has already been fired or
-      // has not been set, trigger swap callback.
-      if (!buffer->wp_presentation_feedback)
-        self->OnBufferSwapped(buffer);
-
+      self->OnSubmission(buffer, gfx::SwapResult::SWAP_ACK);
       return;
     }
   }
-
-  NOTREACHED();
 }
 
 // static
@@ -339,29 +354,20 @@ void WaylandBufferManager::FeedbackPresented(
     uint32_t flags) {
   WaylandBufferManager* self = static_cast<WaylandBufferManager*>(data);
   DCHECK(self);
-
   for (auto& item : self->buffers_) {
     Buffer* buffer = item.second.get();
     if (buffer->wp_presentation_feedback.get() == wp_presentation_feedback) {
-      buffer->feedback = gfx::PresentationFeedback(
-          GetPresentationFeedbackTimeStamp(tv_sec_hi, tv_sec_lo, tv_nsec),
-          base::TimeDelta::FromNanoseconds(refresh),
-          GetPresentationKindFlags(flags));
+      DCHECK(!buffer->presented);
       buffer->wp_presentation_feedback.reset();
-
-      // Some compositors not always fire PresentationFeedback and Frame
-      // events in the same order (i.e, frame callbacks coming always before
-      // feedback presented/discaded ones). So, check FrameCallbackDone has
-      // already been called at this point, if yes, trigger the swap callback.
-      // otherwise it will be triggered in the upcoming frame callback.
-      if (!buffer->wl_frame_callback)
-        self->OnBufferSwapped(buffer);
-
+      self->OnPresentation(
+          buffer,
+          gfx::PresentationFeedback(
+              GetPresentationFeedbackTimeStamp(tv_sec_hi, tv_sec_lo, tv_nsec),
+              base::TimeDelta::FromNanoseconds(refresh),
+              GetPresentationKindFlags(flags)));
       return;
     }
   }
-
-  NOTREACHED();
 }
 
 // static
@@ -370,27 +376,15 @@ void WaylandBufferManager::FeedbackDiscarded(
     struct wp_presentation_feedback* wp_presentation_feedback) {
   WaylandBufferManager* self = static_cast<WaylandBufferManager*>(data);
   DCHECK(self);
-
   for (auto& item : self->buffers_) {
     Buffer* buffer = item.second.get();
     if (buffer->wp_presentation_feedback.get() == wp_presentation_feedback) {
-      // Frame callback must come before a feedback is presented.
-      buffer->feedback = gfx::PresentationFeedback::Failure();
+      DCHECK(!buffer->presented);
       buffer->wp_presentation_feedback.reset();
-
-      // Some compositors not always fire PresentationFeedback and Frame
-      // events in the same order (i.e, frame callbacks coming always before
-      // feedback presented/discaded ones). So, check FrameCallbackDone has
-      // already been called at this point, if yes, trigger the swap callback.
-      // Otherwise it will be triggered in the upcoming frame callback.
-      if (!buffer->wl_frame_callback)
-        self->OnBufferSwapped(buffer);
-
+      self->OnPresentation(buffer, gfx::PresentationFeedback::Failure());
       return;
     }
   }
-
-  NOTREACHED();
 }
 
 }  // namespace ui
diff --git a/ui/ozone/platform/wayland/host/wayland_buffer_manager.h b/ui/ozone/platform/wayland/host/wayland_buffer_manager.h
index 435484a0af3c..c0ea00391b78 100644
--- a/ui/ozone/platform/wayland/host/wayland_buffer_manager.h
+++ b/ui/ozone/platform/wayland/host/wayland_buffer_manager.h
@@ -51,11 +51,13 @@ class WaylandBufferManager {
   // Assigns a wl_buffer with |buffer_id| to a window with the same |widget|. On
   // error, false is returned and |error_message_| is set. A |damage_region|
   // identifies which part of the buffer is updated. If an empty region is
-  // provided, the whole buffer is updated.
+  // provided, the whole buffer is updated. Once a frame callback or
+  // presentation callback is received, WaylandConnection::OnSubmission and
+  // WaylandConnection::OnPresentation are called. Though, it is guaranteed
+  // OnPresentation won't be called earlier than OnSubmission.
   bool ScheduleBufferSwap(gfx::AcceleratedWidget widget,
                           uint32_t buffer_id,
-                          const gfx::Rect& damage_region,
-                          wl::BufferSwapCallback callback);
+                          const gfx::Rect& damage_region);
 
   // Destroys a buffer with |buffer_id| in |buffers_|. On error, false is
   // returned and |error_message_| is set.
@@ -75,13 +77,16 @@ class WaylandBufferManager {
   // to, its buffer id for simplier buffer management and other members specific
   // to this Buffer object on run-time.
   struct Buffer {
-    Buffer();
-    explicit Buffer(const gfx::Size& buffer_size);
+    Buffer() = delete;
+    Buffer(const gfx::Size& buffer_size, uint32_t buffer_id);
     ~Buffer();
 
     // Actual buffer size.
     const gfx::Size size;
 
+    // The id of the buffer.
+    const uint32_t buffer_id;
+
     // Widget to attached/being attach WaylandWindow.
     gfx::AcceleratedWidget widget = gfx::kNullAcceleratedWidget;
 
@@ -90,9 +95,6 @@ class WaylandBufferManager {
     // repainted.
     gfx::Rect damage_region;
 
-    // A buffer swap result once the buffer is committed.
-    gfx::SwapResult swap_result;
-
     // A feedback, which is received if a presentation feedback protocol is
     // supported.
     gfx::PresentationFeedback feedback;
@@ -100,9 +102,9 @@ class WaylandBufferManager {
     // A wl_buffer backed by a dmabuf created on the GPU side.
     wl::Object<struct wl_buffer> wl_buffer;
 
-    // A callback, which is called once the |wl_frame_callback| from the server
-    // is received.
-    wl::BufferSwapCallback buffer_swap_callback;
+    // Provide the status of this buffer. Reset on each new swap.
+    bool swapped = false;
+    bool presented = false;
 
     // A Wayland callback, which is triggered once wl_buffer has been committed
     // and it is right time to notify the GPU that it can start a new drawing
@@ -137,7 +139,9 @@ class WaylandBufferManager {
   void OnCreateBufferComplete(uint32_t buffer_id,
                               wl::Object<struct wl_buffer> new_buffer);
 
-  void OnBufferSwapped(Buffer* buffer);
+  void OnSubmission(Buffer* buffer, const gfx::SwapResult& swap_result);
+  void OnPresentation(Buffer* buffer,
+                      const gfx::PresentationFeedback& feedback);
 
   // wl_callback_listener
   static void FrameCallbackDone(void* data,
diff --git a/ui/ozone/platform/wayland/host/wayland_connection.cc b/ui/ozone/platform/wayland/host/wayland_connection.cc
index 0d10fa3c9860..0be2a976330c 100644
--- a/ui/ozone/platform/wayland/host/wayland_connection.cc
+++ b/ui/ozone/platform/wayland/host/wayland_connection.cc
@@ -183,6 +183,11 @@ int WaylandConnection::GetKeyboardModifiers() const {
   return modifiers;
 }
 
+void WaylandConnection::SetWaylandConnectionClient(
+    ozone::mojom::WaylandConnectionClientAssociatedPtrInfo client) {
+  client_associated_ptr_.Bind(std::move(client));
+}
+
 void WaylandConnection::CreateZwpLinuxDmabuf(
     base::File file,
     uint32_t width,
@@ -212,18 +217,14 @@ void WaylandConnection::DestroyZwpLinuxDmabuf(uint32_t buffer_id) {
   }
 }
 
-void WaylandConnection::ScheduleBufferSwap(
-    gfx::AcceleratedWidget widget,
-    uint32_t buffer_id,
-    const gfx::Rect& damage_region,
-    ScheduleBufferSwapCallback callback) {
+void WaylandConnection::ScheduleBufferSwap(gfx::AcceleratedWidget widget,
+                                           uint32_t buffer_id,
+                                           const gfx::Rect& damage_region) {
   DCHECK(base::MessageLoopCurrentForUI::IsSet());
 
   CHECK(buffer_manager_);
-  if (!buffer_manager_->ScheduleBufferSwap(widget, buffer_id, damage_region,
-                                           std::move(callback))) {
+  if (!buffer_manager_->ScheduleBufferSwap(widget, buffer_id, damage_region))
     TerminateGpuProcess(buffer_manager_->error_message());
-  }
 }
 
 void WaylandConnection::CreateShmBufferForWidget(gfx::AcceleratedWidget widget,
@@ -249,6 +250,21 @@ void WaylandConnection::DestroyShmBuffer(gfx::AcceleratedWidget widget) {
     TerminateGpuProcess("Failed to destroy SHM buffer.");
 }
 
+void WaylandConnection::OnSubmission(gfx::AcceleratedWidget widget,
+                                     uint32_t buffer_id,
+                                     const gfx::SwapResult& swap_result) {
+  DCHECK(client_associated_ptr_);
+  client_associated_ptr_->OnSubmission(widget, buffer_id, swap_result);
+}
+
+void WaylandConnection::OnPresentation(
+    gfx::AcceleratedWidget widget,
+    uint32_t buffer_id,
+    const gfx::PresentationFeedback& feedback) {
+  DCHECK(client_associated_ptr_);
+  client_associated_ptr_->OnPresentation(widget, buffer_id, feedback);
+}
+
 PlatformClipboard* WaylandConnection::GetPlatformClipboard() {
   return this;
 }
@@ -295,7 +311,8 @@ ozone::mojom::WaylandConnectionPtr WaylandConnection::BindInterface() {
 }
 
 void WaylandConnection::OnChannelDestroyed() {
-  binding_.Unbind();
+  client_associated_ptr_.reset();
+  binding_.Close();
   if (buffer_manager_)
     buffer_manager_->ClearState();
 }
diff --git a/ui/ozone/platform/wayland/host/wayland_connection.h b/ui/ozone/platform/wayland/host/wayland_connection.h
index c1ec0412bee6..2edbdb7e403d 100644
--- a/ui/ozone/platform/wayland/host/wayland_connection.h
+++ b/ui/ozone/platform/wayland/host/wayland_connection.h
@@ -52,6 +52,8 @@ class WaylandConnection : public PlatformEventSource,
   //
   // These overridden methods below are invoked by the GPU when hardware
   // accelerated rendering is used.
+  void SetWaylandConnectionClient(
+      ozone::mojom::WaylandConnectionClientAssociatedPtrInfo client) override;
   //
   // Called by the GPU and asks to import a wl_buffer based on a gbm file
   // descriptor.
@@ -68,13 +70,14 @@ class WaylandConnection : public PlatformEventSource,
   void DestroyZwpLinuxDmabuf(uint32_t buffer_id) override;
   // Called by the GPU and asks to attach a wl_buffer with a |buffer_id| to a
   // WaylandWindow with the specified |widget|.
+  // Calls OnSubmission and OnPresentation on successful swap and pixels
+  // presented.
   void ScheduleBufferSwap(gfx::AcceleratedWidget widget,
                           uint32_t buffer_id,
-                          const gfx::Rect& damage_region,
-                          ScheduleBufferSwapCallback callback) override;
+                          const gfx::Rect& damage_region) override;
   // These overridden methods below are invoked by the GPU when hardware
   // accelerated rendering is not used. Check comments in the
-  // ui/ozone/public/interfaces/wayland/host/wayland_connection.mojom.
+  // ui/ozone/public/interfaces/wayland/wayland_connection.mojom.
   void CreateShmBufferForWidget(gfx::AcceleratedWidget widget,
                                 base::File file,
                                 uint64_t length,
@@ -83,6 +86,20 @@ class WaylandConnection : public PlatformEventSource,
                                  const gfx::Rect& damage) override;
   void DestroyShmBuffer(gfx::AcceleratedWidget widget) override;
 
+  // These methods are exclusively used by the WaylandBufferManager to notify
+  // the |client_associated_ptr_| about buffer swaps' results.
+  // TODO(msisov): move these and the above mojo methods into the
+  // WaylandBufferManager and establish end-to-end communication with
+  // WaylandBufferManagerGpu and WaylandBufferManagerHost instead (basically, to
+  // avoid having the WaylandConnection as proxy in between).
+  // https://crbug.com/947411
+  void OnSubmission(gfx::AcceleratedWidget widget,
+                    uint32_t buffer_id,
+                    const gfx::SwapResult& swap_result);
+  void OnPresentation(gfx::AcceleratedWidget widget,
+                      uint32_t buffer_id,
+                      const gfx::PresentationFeedback& feedback);
+
   // Schedules a flush of the Wayland connection.
   void ScheduleFlush();
 
@@ -278,6 +295,7 @@ class WaylandConnection : public PlatformEventSource,
   // Stores the callback to be invoked upon data reading from clipboard.
   RequestDataClosure read_clipboard_closure_;
 
+  ozone::mojom::WaylandConnectionClientAssociatedPtr client_associated_ptr_;
   mojo::Binding<ozone::mojom::WaylandConnection> binding_;
 
   // A callback, which is used to terminate a GPU process in case of invalid
diff --git a/ui/ozone/platform/wayland/ozone_platform_wayland.cc b/ui/ozone/platform/wayland/ozone_platform_wayland.cc
index 202e146bcbc6..55a51f93e945 100644
--- a/ui/ozone/platform/wayland/ozone_platform_wayland.cc
+++ b/ui/ozone/platform/wayland/ozone_platform_wayland.cc
@@ -167,8 +167,10 @@ class OzonePlatformWayland : public OzonePlatform {
   }
 
   void InitializeGPU(const InitParams& args) override {
-    proxy_.reset(new WaylandConnectionProxy(connection_.get()));
-    surface_factory_.reset(new WaylandSurfaceFactory(proxy_.get()));
+    surface_factory_ = std::make_unique<WaylandSurfaceFactory>();
+    proxy_ = std::make_unique<WaylandConnectionProxy>(connection_.get(),
+                                                      surface_factory_.get());
+    surface_factory_->SetProxy(proxy_.get());
 #if defined(WAYLAND_GBM)
     const base::FilePath drm_node_path = path_finder_.GetDrmRenderNodePath();
     if (drm_node_path.empty()) {
diff --git a/ui/ozone/platform/wayland/test/wayland_test.cc b/ui/ozone/platform/wayland/test/wayland_test.cc
index 11f3b7a021d1..e96443bb8e7b 100644
--- a/ui/ozone/platform/wayland/test/wayland_test.cc
+++ b/ui/ozone/platform/wayland/test/wayland_test.cc
@@ -31,7 +31,8 @@ WaylandTest::WaylandTest()
       std::make_unique<StubKeyboardLayoutEngine>());
 #endif
   connection_.reset(new WaylandConnection);
-  connection_proxy_.reset(new WaylandConnectionProxy(connection_.get()));
+  connection_proxy_.reset(
+      new WaylandConnectionProxy(connection_.get(), nullptr));
   window_ = std::make_unique<WaylandWindow>(&delegate_, connection_.get());
 }
 
diff --git a/ui/ozone/public/interfaces/wayland/wayland_connection.mojom b/ui/ozone/public/interfaces/wayland/wayland_connection.mojom
index f7fc67762911..713ac9a210e7 100644
--- a/ui/ozone/public/interfaces/wayland/wayland_connection.mojom
+++ b/ui/ozone/public/interfaces/wayland/wayland_connection.mojom
@@ -14,6 +14,9 @@ import "ui/gfx/mojo/swap_result.mojom";
 // Used by the GPU for communication with a WaylandConnection on the browser
 // process.
 interface WaylandConnection {
+  // Sets up an associated pipe between the Client and Host.
+  SetWaylandConnectionClient(associated WaylandConnectionClient client);
+
   // Methods used for hardware accelerated rendering:
   //
   // Asks Wayland to create a wl_buffer based on the dmabuf |file| descriptor.
@@ -32,9 +35,7 @@ interface WaylandConnection {
 
   // Swaps wl_buffers for a WaylandWindow with the following |widget|.
   ScheduleBufferSwap(gfx.mojom.AcceleratedWidget widget, uint32 buffer_id,
-                     gfx.mojom.Rect damage_region)
-      => (gfx.mojom.SwapResult swap_result,
-          gfx.mojom.PresentationFeedback feedback);
+                     gfx.mojom.Rect damage_region);
 
   // Methods used for software rendering:
   //
@@ -65,4 +66,14 @@ interface WaylandConnectionClient {
   // avoid using zwp_linux_dmabuf protocol, which means using wl_egl_surface in
   // a single process mode, and software rendering in a multiple process mode.
   ResetGbmDevice();
+
+  // Signals about swap completion.
+  OnSubmission(gfx.mojom.AcceleratedWidget widget,
+               uint32 buffer_id,
+               gfx.mojom.SwapResult swap_result);
+
+  // Signals about presentation.
+  OnPresentation(gfx.mojom.AcceleratedWidget widget,
+                 uint32 buffer_id,
+                 gfx.mojom.PresentationFeedback feedback);
 };
-- 
2.20.1

