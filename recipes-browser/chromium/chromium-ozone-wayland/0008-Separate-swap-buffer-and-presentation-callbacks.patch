Upstream-Status: Backport

Signed-off-by: Maksim Sisov <msisov@igalia.com>
---
From 9a219ef95df2e87acfc580bdc8f590a96756e146 Mon Sep 17 00:00:00 2001
From: Maksim Sisov <msisov@igalia.com>
Date: Thu, 4 Apr 2019 06:10:29 +0000
Subject: [PATCH 08/11] Separate swap buffer and presentation callbacks

Previously, the WaylandBufferManager did not send swap completion
callbacks before the presentation feedback was available.

This resulted in delays and blocked the display compositor as long
as it was waiting for the swap ack => perf regression.

Thus, split the callbacks and handle them separately.

In the follow up CLs, I will also move the submit frame queue
from the GbmSurfacelessWayland to WaylandBufferManager, which
receives frame callbacks and able to send the pending buffers as
soon as possible. Also, it will use buffer release callbacks, which
may come earlier that frame callbacks.

Bug: 943096
Change-Id: Ia51389b6cbbe736d19cb22e1f6532faf5e0477f4
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1538195
Reviewed-by: Michael Spang <spang@chromium.org>
Reviewed-by: Tom Sepez <tsepez@chromium.org>
Commit-Queue: Maksim Sisov <msisov@igalia.com>
Cr-Commit-Position: refs/heads/master@{#647629}
---
 .../platform/wayland/common/wayland_util.h    |   6 -
 .../wayland/gpu/gbm_pixmap_wayland.cc         |   9 +-
 .../platform/wayland/gpu/gbm_pixmap_wayland.h |  10 +-
 .../wayland/gpu/gbm_surfaceless_wayland.cc    |  64 ++++-----
 .../wayland/gpu/gbm_surfaceless_wayland.h     |  21 +--
 .../wayland/gpu/wayland_connection_proxy.cc   |  79 ++++++++---
 .../wayland/gpu/wayland_connection_proxy.h    |  43 ++++--
 .../wayland/gpu/wayland_surface_factory.cc    |  44 +++---
 .../wayland/gpu/wayland_surface_factory.h     |  12 +-
 .../wayland/host/wayland_buffer_manager.cc    | 126 +++++++++---------
 .../wayland/host/wayland_buffer_manager.h     |  28 ++--
 .../wayland/host/wayland_connection.cc        |  35 +++--
 .../wayland/host/wayland_connection.h         |  24 +++-
 .../wayland/ozone_platform_wayland.cc         |   6 +-
 .../platform/wayland/test/wayland_test.cc     |   3 +-
 .../wayland/wayland_connection.mojom          |  17 ++-
 16 files changed, 323 insertions(+), 204 deletions(-)

diff --git a/ui/ozone/platform/wayland/common/wayland_util.h b/ui/ozone/platform/wayland/common/wayland_util.h
index 971a00345eb7..a7bdafbe0d01 100644
--- a/ui/ozone/platform/wayland/common/wayland_util.h
+++ b/ui/ozone/platform/wayland/common/wayland_util.h
@@ -25,16 +25,10 @@ class WaylandConnection;
 
 namespace gfx {
 class Size;
-enum class SwapResult;
-struct PresentationFeedback;
 }
 
 namespace wl {
 
-// Corresponds to mojom::WaylandConnection::ScheduleBufferSwapCallback.
-using BufferSwapCallback =
-    base::OnceCallback<void(gfx::SwapResult, const gfx::PresentationFeedback&)>;
-
 using RequestSizeCallback = base::OnceCallback<void(const gfx::Size&)>;
 
 using OnRequestBufferCallback =
diff --git a/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.cc b/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.cc
index f2db8e7567f8..585a3d8f31c6 100644
--- a/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.cc
+++ b/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.cc
@@ -27,12 +27,15 @@
 namespace ui {
 
 GbmPixmapWayland::GbmPixmapWayland(WaylandSurfaceFactory* surface_manager,
-                                   WaylandConnectionProxy* connection)
-    : surface_manager_(surface_manager), connection_(connection) {}
+                                   WaylandConnectionProxy* connection,
+                                   gfx::AcceleratedWidget widget)
+    : surface_manager_(surface_manager),
+      connection_(connection),
+      widget_(widget) {}
 
 GbmPixmapWayland::~GbmPixmapWayland() {
   if (gbm_bo_)
-    connection_->DestroyZwpLinuxDmabuf(GetUniqueId());
+    connection_->DestroyZwpLinuxDmabuf(widget_, GetUniqueId());
 }
 
 bool GbmPixmapWayland::InitializeBuffer(gfx::Size size,
diff --git a/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.h b/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.h
index 6998041936ba..e456f9e81b6f 100644
--- a/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.h
+++ b/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.h
@@ -22,7 +22,8 @@ class WaylandConnectionProxy;
 class GbmPixmapWayland : public gfx::NativePixmap {
  public:
   GbmPixmapWayland(WaylandSurfaceFactory* surface_manager,
-                   WaylandConnectionProxy* connection);
+                   WaylandConnectionProxy* connection,
+                   gfx::AcceleratedWidget widget);
 
   // Creates a buffer object and initializes the pixmap buffer.
   bool InitializeBuffer(gfx::Size size,
@@ -57,10 +58,13 @@ class GbmPixmapWayland : public gfx::NativePixmap {
   // gbm_bo wrapper for struct gbm_bo.
   std::unique_ptr<GbmBuffer> gbm_bo_;
 
-  WaylandSurfaceFactory* surface_manager_ = nullptr;
+  WaylandSurfaceFactory* const surface_manager_;
 
   // Represents a connection to Wayland.
-  WaylandConnectionProxy* connection_ = nullptr;
+  WaylandConnectionProxy* const connection_;
+
+  // Represents widget this pixmap backs.
+  const gfx::AcceleratedWidget widget_;
 
   DISALLOW_COPY_AND_ASSIGN(GbmPixmapWayland);
 };
diff --git a/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.cc b/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.cc
index c4bc47e96b5f..e97eea1dbe7a 100644
--- a/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.cc
+++ b/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.cc
@@ -9,6 +9,7 @@
 #include "base/trace_event/trace_event.h"
 #include "ui/gfx/gpu_fence.h"
 #include "ui/ozone/common/egl_util.h"
+#include "ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h"
 #include "ui/ozone/platform/wayland/gpu/wayland_surface_factory.h"
 
 namespace ui {
@@ -25,9 +26,11 @@ void WaitForFence(EGLDisplay display, EGLSyncKHR fence) {
 
 GbmSurfacelessWayland::GbmSurfacelessWayland(
     WaylandSurfaceFactory* surface_factory,
+    WaylandConnectionProxy* connection,
     gfx::AcceleratedWidget widget)
     : SurfacelessEGL(gfx::Size()),
       surface_factory_(surface_factory),
+      connection_(connection),
       widget_(widget),
       has_implicit_external_sync_(
           HasEGLExtension("EGL_ARM_implicit_external_sync")),
@@ -202,18 +205,23 @@ void GbmSurfacelessWayland::SubmitFrame() {
         submitted_frame_->ScheduleOverlayPlanes(widget_);
 
     if (!schedule_planes_succeeded) {
-      OnSubmission(gfx::SwapResult::SWAP_FAILED, nullptr);
-      OnPresentation(gfx::PresentationFeedback::Failure());
+      last_swap_buffers_result_ = false;
+
+      std::move(submitted_frame_->completion_callback)
+          .Run(gfx::SwapResult::SWAP_FAILED, nullptr);
+      // Notify the caller, the buffer is never presented on a screen.
+      std::move(submitted_frame_->presentation_callback)
+          .Run(gfx::PresentationFeedback::Failure());
+
+      submitted_frame_.reset();
       return;
     }
 
-    auto callback =
-        base::BindOnce(&GbmSurfacelessWayland::OnScheduleBufferSwapDone,
-                       weak_factory_.GetWeakPtr());
-    uint32_t buffer_id = planes_.back().pixmap->GetUniqueId();
-    surface_factory_->ScheduleBufferSwap(widget_, buffer_id,
-                                         submitted_frame_->damage_region_,
-                                         std::move(callback));
+    submitted_frame_->buffer_id = planes_.back().pixmap->GetUniqueId();
+    connection_->ScheduleBufferSwap(widget_, submitted_frame_->buffer_id,
+                                    submitted_frame_->damage_region_);
+
+    planes_.clear();
   }
 }
 
@@ -230,31 +238,16 @@ void GbmSurfacelessWayland::FenceRetired(PendingFrame* frame) {
   SubmitFrame();
 }
 
-void GbmSurfacelessWayland::OnScheduleBufferSwapDone(
-    gfx::SwapResult result,
-    const gfx::PresentationFeedback& feedback) {
-  OnSubmission(result, nullptr);
-  OnPresentation(feedback);
-  planes_.clear();
-}
-
-void GbmSurfacelessWayland::OnSubmission(
-    gfx::SwapResult result,
-    std::unique_ptr<gfx::GpuFence> out_fence) {
-  submitted_frame_->swap_result = result;
-}
-
-void GbmSurfacelessWayland::OnPresentation(
-    const gfx::PresentationFeedback& feedback) {
-  // Explicitly destroy overlays to free resources (e.g., fences) early.
+void GbmSurfacelessWayland::OnSubmission(uint32_t buffer_id,
+                                         const gfx::SwapResult& swap_result) {
   submitted_frame_->overlays.clear();
 
-  gfx::SwapResult result = submitted_frame_->swap_result;
-  std::move(submitted_frame_->completion_callback).Run(result, nullptr);
-  std::move(submitted_frame_->presentation_callback).Run(feedback);
-  submitted_frame_.reset();
+  DCHECK_EQ(submitted_frame_->buffer_id, buffer_id);
+  std::move(submitted_frame_->completion_callback).Run(swap_result, nullptr);
 
-  if (result == gfx::SwapResult::SWAP_FAILED) {
+  pending_presentation_frames_.push_back(std::move(submitted_frame_));
+
+  if (swap_result != gfx::SwapResult::SWAP_ACK) {
     last_swap_buffers_result_ = false;
     return;
   }
@@ -262,4 +255,13 @@ void GbmSurfacelessWayland::OnPresentation(
   SubmitFrame();
 }
 
+void GbmSurfacelessWayland::OnPresentation(
+    uint32_t buffer_id,
+    const gfx::PresentationFeedback& feedback) {
+  auto* frame = pending_presentation_frames_.front().get();
+  DCHECK_EQ(frame->buffer_id, buffer_id);
+  std::move(frame->presentation_callback).Run(feedback);
+  pending_presentation_frames_.erase(pending_presentation_frames_.begin());
+}
+
 }  // namespace ui
diff --git a/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.h b/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.h
index 15b5e902989a..0155b8d0460d 100644
--- a/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.h
+++ b/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.h
@@ -14,6 +14,7 @@
 
 namespace ui {
 
+class WaylandConnectionProxy;
 class WaylandSurfaceFactory;
 
 // A GLSurface for Wayland Ozone platform that uses surfaceless drawing. Drawing
@@ -23,6 +24,7 @@ class WaylandSurfaceFactory;
 class GbmSurfacelessWayland : public gl::SurfacelessEGL {
  public:
   GbmSurfacelessWayland(WaylandSurfaceFactory* surface_factory,
+                        WaylandConnectionProxy* connection,
                         gfx::AcceleratedWidget widget);
 
   void QueueOverlayPlane(OverlayPlane plane);
@@ -57,6 +59,10 @@ class GbmSurfacelessWayland : public gl::SurfacelessEGL {
   EGLConfig GetConfig() override;
   void SetRelyOnImplicitSync() override;
 
+  void OnSubmission(uint32_t buffer_id, const gfx::SwapResult& swap_result);
+  void OnPresentation(uint32_t buffer_id,
+                      const gfx::PresentationFeedback& feedback);
+
  private:
   ~GbmSurfacelessWayland() override;
 
@@ -68,7 +74,10 @@ class GbmSurfacelessWayland : public gl::SurfacelessEGL {
     void Flush();
 
     bool ready = false;
-    gfx::SwapResult swap_result = gfx::SwapResult::SWAP_FAILED;
+
+    // The id of the buffer, which represents this frame.
+    uint32_t buffer_id = 0;
+
     // A region of the updated content in a corresponding frame. It's used to
     // advice Wayland which part of a buffer is going to be updated. Passing {0,
     // 0, 0, 0} results in a whole buffer update on the Wayland compositor side.
@@ -83,18 +92,14 @@ class GbmSurfacelessWayland : public gl::SurfacelessEGL {
   EGLSyncKHR InsertFence(bool implicit);
   void FenceRetired(PendingFrame* frame);
 
-  void OnScheduleBufferSwapDone(gfx::SwapResult result,
-                                const gfx::PresentationFeedback& feedback);
-  void OnSubmission(gfx::SwapResult result,
-                    std::unique_ptr<gfx::GpuFence> out_fence);
-  void OnPresentation(const gfx::PresentationFeedback& feedback);
-
-  WaylandSurfaceFactory* surface_factory_;
+  WaylandSurfaceFactory* const surface_factory_;
+  WaylandConnectionProxy* const connection_;
   std::vector<OverlayPlane> planes_;
 
   // The native surface. Deleting this is allowed to free the EGLNativeWindow.
   gfx::AcceleratedWidget widget_;
   std::vector<std::unique_ptr<PendingFrame>> unsubmitted_frames_;
+  std::vector<std::unique_ptr<PendingFrame>> pending_presentation_frames_;
   std::unique_ptr<PendingFrame> submitted_frame_;
   bool has_implicit_external_sync_;
   bool last_swap_buffers_result_ = true;
diff --git a/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.cc b/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.cc
index c8109597f506..0c46d34c4769 100644
--- a/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.cc
+++ b/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.cc
@@ -7,14 +7,20 @@
 #include <utility>
 
 #include "base/process/process.h"
+#include "mojo/public/cpp/bindings/associated_interface_ptr.h"
 #include "third_party/khronos/EGL/egl.h"
 #include "ui/ozone/common/linux/drm_util_linux.h"
+#include "ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.h"
+#include "ui/ozone/platform/wayland/gpu/wayland_surface_factory.h"
 #include "ui/ozone/platform/wayland/host/wayland_connection.h"
 
 namespace ui {
 
-WaylandConnectionProxy::WaylandConnectionProxy(WaylandConnection* connection)
+WaylandConnectionProxy::WaylandConnectionProxy(WaylandConnection* connection,
+                                               WaylandSurfaceFactory* factory)
     : connection_(connection),
+      factory_(factory),
+      associated_binding_(this),
       gpu_thread_runner_(base::ThreadTaskRunnerHandle::Get()) {}
 
 WaylandConnectionProxy::~WaylandConnectionProxy() = default;
@@ -34,6 +40,33 @@ void WaylandConnectionProxy::ResetGbmDevice() {
 #endif
 }
 
+void WaylandConnectionProxy::OnSubmission(gfx::AcceleratedWidget widget,
+                                          uint32_t buffer_id,
+                                          gfx::SwapResult swap_result) {
+  DCHECK(gpu_thread_runner_->BelongsToCurrentThread());
+  DCHECK_NE(widget, gfx::kNullAcceleratedWidget);
+  auto* surface = factory_->GetSurface(widget);
+  // There can be a race between destruction and submitting the last frames. The
+  // surface can be destroyed by the time the host receives a request to destroy
+  // a buffer, and is able to call the OnSubmission for that specific buffer.
+  if (surface)
+    surface->OnSubmission(buffer_id, swap_result);
+}
+
+void WaylandConnectionProxy::OnPresentation(
+    gfx::AcceleratedWidget widget,
+    uint32_t buffer_id,
+    const gfx::PresentationFeedback& feedback) {
+  DCHECK(gpu_thread_runner_->BelongsToCurrentThread());
+  DCHECK_NE(widget, gfx::kNullAcceleratedWidget);
+  auto* surface = factory_->GetSurface(widget);
+  // There can be a race between destruction and presenting the last frames. The
+  // surface can be destroyed by the time the host receives a request to destroy
+  // a buffer, and is able to call the OnPresentation for that specific buffer.
+  if (surface)
+    surface->OnPresentation(buffer_id, feedback);
+}
+
 void WaylandConnectionProxy::CreateZwpLinuxDmabuf(
     base::File file,
     gfx::Size size,
@@ -68,10 +101,9 @@ void WaylandConnectionProxy::CreateZwpLinuxDmabufInternal(
   // from the thread, which is used to call these methods. Thus, rebind the
   // interface on a first call to ensure mojo calls will always happen on a
   // sequence we want.
-  if (!bound_) {
-    wc_ptr_.Bind(std::move(wc_ptr_info_));
-    bound_ = true;
-  }
+  if (!wc_ptr_.is_bound())
+    BindHostInterface();
+
   DCHECK(gpu_thread_runner_->BelongsToCurrentThread());
   DCHECK(wc_ptr_);
   wc_ptr_->CreateZwpLinuxDmabuf(std::move(file), size.width(), size.height(),
@@ -79,31 +111,36 @@ void WaylandConnectionProxy::CreateZwpLinuxDmabufInternal(
                                 planes_count, buffer_id);
 }
 
-void WaylandConnectionProxy::DestroyZwpLinuxDmabuf(uint32_t buffer_id) {
+void WaylandConnectionProxy::DestroyZwpLinuxDmabuf(
+    gfx::AcceleratedWidget widget,
+    uint32_t buffer_id) {
   DCHECK(gpu_thread_runner_);
+
   // Do a mojo call on the GpuMainThread instead of the io child thread to
   // ensure proper functionality.
   gpu_thread_runner_->PostTask(
       FROM_HERE,
       base::BindOnce(&WaylandConnectionProxy::DestroyZwpLinuxDmabufInternal,
-                     base::Unretained(this), buffer_id));
+                     base::Unretained(this), widget, buffer_id));
 }
 
-void WaylandConnectionProxy::DestroyZwpLinuxDmabufInternal(uint32_t buffer_id) {
+void WaylandConnectionProxy::DestroyZwpLinuxDmabufInternal(
+    gfx::AcceleratedWidget widget,
+    uint32_t buffer_id) {
   DCHECK(gpu_thread_runner_->BelongsToCurrentThread());
   DCHECK(wc_ptr_);
+
   wc_ptr_->DestroyZwpLinuxDmabuf(buffer_id);
 }
 
 void WaylandConnectionProxy::ScheduleBufferSwap(
     gfx::AcceleratedWidget widget,
     uint32_t buffer_id,
-    const gfx::Rect& damage_region,
-    wl::BufferSwapCallback callback) {
+    const gfx::Rect& damage_region) {
   DCHECK(gpu_thread_runner_->BelongsToCurrentThread());
   DCHECK(wc_ptr_);
-  wc_ptr_->ScheduleBufferSwap(widget, buffer_id, damage_region,
-                              std::move(callback));
+
+  wc_ptr_->ScheduleBufferSwap(widget, buffer_id, damage_region);
 }
 
 void WaylandConnectionProxy::CreateShmBufferForWidget(
@@ -111,10 +148,9 @@ void WaylandConnectionProxy::CreateShmBufferForWidget(
     base::File file,
     size_t length,
     const gfx::Size size) {
-  if (!bound_) {
-    wc_ptr_.Bind(std::move(wc_ptr_info_));
-    bound_ = true;
-  }
+  if (!wc_ptr_.is_bound())
+    BindHostInterface();
+
   DCHECK(wc_ptr_);
   wc_ptr_->CreateShmBufferForWidget(widget, std::move(file), length, size);
 }
@@ -162,4 +198,15 @@ void WaylandConnectionProxy::AddBindingWaylandConnectionClient(
   bindings_.AddBinding(this, std::move(request));
 }
 
+void WaylandConnectionProxy::BindHostInterface() {
+  DCHECK(!wc_ptr_.is_bound());
+  wc_ptr_.Bind(std::move(wc_ptr_info_));
+
+  // Setup associated interface.
+  ozone::mojom::WaylandConnectionClientAssociatedPtrInfo client_ptr_info;
+  auto request = MakeRequest(&client_ptr_info);
+  wc_ptr_->SetWaylandConnectionClient(std::move(client_ptr_info));
+  associated_binding_.Bind(std::move(request));
+}
+
 }  // namespace ui
diff --git a/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h b/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h
index f87d0b5ac4de..2335c93192fa 100644
--- a/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h
+++ b/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h
@@ -8,8 +8,10 @@
 #include "base/macros.h"
 #include "base/threading/sequenced_task_runner_handle.h"
 #include "base/threading/thread_checker.h"
+#include "mojo/public/cpp/bindings/associated_binding.h"
 #include "mojo/public/cpp/bindings/binding_set.h"
 #include "ui/gfx/native_widget_types.h"
+#include "ui/gl/gl_surface.h"
 #include "ui/ozone/platform/wayland/common/wayland_util.h"
 #include "ui/ozone/platform/wayland/host/wayland_connection.h"
 #include "ui/ozone/public/interfaces/wayland/wayland_connection.mojom.h"
@@ -26,6 +28,7 @@ class Rect;
 namespace ui {
 
 class WaylandConnection;
+class WaylandSurfaceFactory;
 class WaylandWindow;
 
 // Provides a proxy connection to a WaylandConnection object on
@@ -37,12 +40,22 @@ class WaylandWindow;
 // sequence.
 class WaylandConnectionProxy : public ozone::mojom::WaylandConnectionClient {
  public:
-  explicit WaylandConnectionProxy(WaylandConnection* connection);
+  WaylandConnectionProxy(WaylandConnection* connection,
+                         WaylandSurfaceFactory* factory);
   ~WaylandConnectionProxy() override;
 
   // WaylandConnectionProxy overrides:
   void SetWaylandConnection(ozone::mojom::WaylandConnectionPtr wc_ptr) override;
   void ResetGbmDevice() override;
+  // These two calls get the surface, which backs the |widget| and notifies it
+  // about the submission and the presentation. After the surface receives the
+  // OnSubmission call, it can schedule a new buffer for swap.
+  void OnSubmission(gfx::AcceleratedWidget widget,
+                    uint32_t buffer_id,
+                    gfx::SwapResult swap_result) override;
+  void OnPresentation(gfx::AcceleratedWidget widget,
+                      uint32_t buffer_id,
+                      const gfx::PresentationFeedback& feedback) override;
 
   // Methods, which must be used when GPU is hosted on a different process
   // aka gpu process.
@@ -59,16 +72,21 @@ class WaylandConnectionProxy : public ozone::mojom::WaylandConnectionClient {
                             uint32_t buffer_id);
 
   // Asks Wayland to destroy a wl_buffer.
-  void DestroyZwpLinuxDmabuf(uint32_t buffer_id);
+  void DestroyZwpLinuxDmabuf(gfx::AcceleratedWidget widget, uint32_t buffer_id);
 
   // Asks Wayland to find a wl_buffer with the |buffer_id| and schedule a
   // buffer swap for a WaylandWindow, which backs the following |widget|.
-  // The |callback| is called once a frame callback from the Wayland server
-  // is received.
+  // Once the buffer is submitted and presented, the OnSubmission and
+  // OnPresentation are called. Note, it's not guaranteed the OnPresentation
+  // will follow the OnSubmission immediately, but the OnPresentation must never
+  // be called before the OnSubmission is called for that particular buffer.
+  // This logic must be checked by the client, though the host ensures this
+  // logic as well. This call must not be done twice for the same |widget| until
+  // the OnSubmission is called (which actually means the client can continue
+  // sending buffer swap requests).
   void ScheduleBufferSwap(gfx::AcceleratedWidget widget,
                           uint32_t buffer_id,
-                          const gfx::Rect& damage_region,
-                          wl::BufferSwapCallback callback);
+                          const gfx::Rect& damage_region);
 
 #if defined(WAYLAND_GBM)
   // Returns a gbm_device based on a DRM render node.
@@ -125,12 +143,19 @@ class WaylandConnectionProxy : public ozone::mojom::WaylandConnectionClient {
                                     uint32_t current_format,
                                     uint32_t planes_count,
                                     uint32_t buffer_id);
-  void DestroyZwpLinuxDmabufInternal(uint32_t buffer_id);
+  void DestroyZwpLinuxDmabufInternal(gfx::AcceleratedWidget widget,
+                                     uint32_t buffer_id);
+
+  void BindHostInterface();
 
   // Non-owned pointer to a WaylandConnection. It is only used in a single
   // process mode, when a shared dmabuf approach is not used.
   WaylandConnection* const connection_;
 
+  // Non-owned. Only used to get registered surfaces and notify them about
+  // submission and presentation of buffers.
+  WaylandSurfaceFactory* const factory_;
+
 #if defined(WAYLAND_GBM)
   // A DRM render node based gbm device.
   std::unique_ptr<GbmDevice> gbm_device_;
@@ -142,7 +167,9 @@ class WaylandConnectionProxy : public ozone::mojom::WaylandConnectionClient {
   // process side. It's used for a multi-process mode.
   ozone::mojom::WaylandConnectionPtr wc_ptr_;
   ozone::mojom::WaylandConnectionPtrInfo wc_ptr_info_;
-  bool bound_ = false;
+
+  mojo::AssociatedBinding<ozone::mojom::WaylandConnectionClient>
+      associated_binding_;
 
   // A task runner, which is initialized in a multi-process mode. It is used to
   // ensure all the methods of this class are run on GpuMainThread. This is
diff --git a/ui/ozone/platform/wayland/gpu/wayland_surface_factory.cc b/ui/ozone/platform/wayland/gpu/wayland_surface_factory.cc
index f21d27293329..d5e32e445d6e 100644
--- a/ui/ozone/platform/wayland/gpu/wayland_surface_factory.cc
+++ b/ui/ozone/platform/wayland/gpu/wayland_surface_factory.cc
@@ -28,8 +28,9 @@ namespace {
 
 class GLOzoneEGLWayland : public GLOzoneEGL {
  public:
-  explicit GLOzoneEGLWayland(WaylandConnectionProxy* connection)
-      : connection_(connection) {}
+  GLOzoneEGLWayland(WaylandConnectionProxy* connection,
+                    WaylandSurfaceFactory* factory)
+      : connection_(connection), factory_(factory) {}
   ~GLOzoneEGLWayland() override {}
 
   scoped_refptr<gl::GLSurface> CreateViewGLSurface(
@@ -46,7 +47,8 @@ class GLOzoneEGLWayland : public GLOzoneEGL {
   bool LoadGLES2Bindings(gl::GLImplementation impl) override;
 
  private:
-  WaylandConnectionProxy* connection_ = nullptr;
+  WaylandConnectionProxy* const connection_;
+  WaylandSurfaceFactory* const factory_;
 
   DISALLOW_COPY_AND_ASSIGN(GLOzoneEGLWayland);
 };
@@ -80,10 +82,8 @@ scoped_refptr<gl::GLSurface> GLOzoneEGLWayland::CreateSurfacelessViewGLSurface(
   // If there is a gbm device available, use surfaceless gl surface.
   if (!connection_->gbm_device())
     return nullptr;
-  return gl::InitializeGLSurface(new GbmSurfacelessWayland(
-      static_cast<WaylandSurfaceFactory*>(
-          OzonePlatform::GetInstance()->GetSurfaceFactoryOzone()),
-      window));
+  return gl::InitializeGLSurface(
+      new GbmSurfacelessWayland(factory_, connection_, window));
 #else
   return nullptr;
 #endif
@@ -112,14 +112,17 @@ bool GLOzoneEGLWayland::LoadGLES2Bindings(gl::GLImplementation impl) {
 
 }  // namespace
 
-WaylandSurfaceFactory::WaylandSurfaceFactory(WaylandConnectionProxy* connection)
-    : connection_(connection) {
-  if (connection_)
-    egl_implementation_ = std::make_unique<GLOzoneEGLWayland>(connection_);
-}
+WaylandSurfaceFactory::WaylandSurfaceFactory() {}
 
 WaylandSurfaceFactory::~WaylandSurfaceFactory() {}
 
+void WaylandSurfaceFactory::SetProxy(WaylandConnectionProxy* proxy) {
+  DCHECK(!connection_ && proxy);
+  connection_ = proxy;
+
+  egl_implementation_ = std::make_unique<GLOzoneEGLWayland>(connection_, this);
+}
+
 void WaylandSurfaceFactory::RegisterSurface(gfx::AcceleratedWidget widget,
                                             GbmSurfacelessWayland* surface) {
   widget_to_surface_map_.insert(std::make_pair(widget, surface));
@@ -131,18 +134,11 @@ void WaylandSurfaceFactory::UnregisterSurface(gfx::AcceleratedWidget widget) {
 
 GbmSurfacelessWayland* WaylandSurfaceFactory::GetSurface(
     gfx::AcceleratedWidget widget) const {
+  GbmSurfacelessWayland* surface = nullptr;
   auto it = widget_to_surface_map_.find(widget);
-  DCHECK(it != widget_to_surface_map_.end());
-  return it->second;
-}
-
-void WaylandSurfaceFactory::ScheduleBufferSwap(
-    gfx::AcceleratedWidget widget,
-    uint32_t buffer_id,
-    const gfx::Rect& damage_region,
-    wl::BufferSwapCallback callback) {
-  connection_->ScheduleBufferSwap(widget, buffer_id, damage_region,
-                                  std::move(callback));
+  if (it != widget_to_surface_map_.end())
+    surface = it->second;
+  return surface;
 }
 
 std::unique_ptr<SurfaceOzoneCanvas>
@@ -178,7 +174,7 @@ scoped_refptr<gfx::NativePixmap> WaylandSurfaceFactory::CreateNativePixmap(
     gfx::BufferUsage usage) {
 #if defined(WAYLAND_GBM)
   scoped_refptr<GbmPixmapWayland> pixmap =
-      base::MakeRefCounted<GbmPixmapWayland>(this, connection_);
+      base::MakeRefCounted<GbmPixmapWayland>(this, connection_, widget);
   if (!pixmap->InitializeBuffer(size, format, usage))
     return nullptr;
   return pixmap;
diff --git a/ui/ozone/platform/wayland/gpu/wayland_surface_factory.h b/ui/ozone/platform/wayland/gpu/wayland_surface_factory.h
index c18c581e87a0..ce68012dee8d 100644
--- a/ui/ozone/platform/wayland/gpu/wayland_surface_factory.h
+++ b/ui/ozone/platform/wayland/gpu/wayland_surface_factory.h
@@ -13,10 +13,6 @@
 #include "ui/ozone/platform/wayland/common/wayland_util.h"
 #include "ui/ozone/public/surface_factory_ozone.h"
 
-namespace gfx {
-class Rect;
-}  // namespace gfx
-
 namespace ui {
 
 class GbmSurfacelessWayland;
@@ -24,14 +20,12 @@ class WaylandConnectionProxy;
 
 class WaylandSurfaceFactory : public SurfaceFactoryOzone {
  public:
-  explicit WaylandSurfaceFactory(WaylandConnectionProxy* connection);
+  WaylandSurfaceFactory();
   ~WaylandSurfaceFactory() override;
 
+  void SetProxy(WaylandConnectionProxy* proxy);
+
   // These methods are used, when a dmabuf based approach is used.
-  void ScheduleBufferSwap(gfx::AcceleratedWidget widget,
-                          uint32_t buffer_id,
-                          const gfx::Rect& damage_region_,
-                          wl::BufferSwapCallback callback);
   void RegisterSurface(gfx::AcceleratedWidget widget,
                        GbmSurfacelessWayland* surface);
   void UnregisterSurface(gfx::AcceleratedWidget widget);
diff --git a/ui/ozone/platform/wayland/host/wayland_buffer_manager.cc b/ui/ozone/platform/wayland/host/wayland_buffer_manager.cc
index 98b1d069f26b..0d1b328d62ef 100644
--- a/ui/ozone/platform/wayland/host/wayland_buffer_manager.cc
+++ b/ui/ozone/platform/wayland/host/wayland_buffer_manager.cc
@@ -41,9 +41,9 @@ base::TimeTicks GetPresentationFeedbackTimeStamp(uint32_t tv_sec_hi,
 
 }  // namespace
 
-WaylandBufferManager::Buffer::Buffer() = default;
-WaylandBufferManager::Buffer::Buffer(const gfx::Size& buffer_size)
-    : size(buffer_size) {}
+WaylandBufferManager::Buffer::Buffer(const gfx::Size& buffer_size,
+                                     uint32_t buffer_id)
+    : size(buffer_size), buffer_id(buffer_id) {}
 WaylandBufferManager::Buffer::~Buffer() = default;
 
 WaylandBufferManager::WaylandBufferManager(WaylandConnection* connection)
@@ -74,7 +74,7 @@ bool WaylandBufferManager::CreateBuffer(base::File file,
   }
 
   std::unique_ptr<Buffer> buffer =
-      std::make_unique<Buffer>(gfx::Size(width, height));
+      std::make_unique<Buffer>(gfx::Size(width, height), buffer_id);
   buffers_.insert(std::make_pair(buffer_id, std::move(buffer)));
 
   auto callback = base::BindOnce(&WaylandBufferManager::OnCreateBufferComplete,
@@ -85,12 +85,10 @@ bool WaylandBufferManager::CreateBuffer(base::File file,
   return true;
 }
 
-// TODO(msisov): handle buffer swap failure or success.
 bool WaylandBufferManager::ScheduleBufferSwap(gfx::AcceleratedWidget widget,
                                               uint32_t buffer_id,
-                                              const gfx::Rect& damage_region,
-                                              wl::BufferSwapCallback callback) {
-  TRACE_EVENT1("wayland", "WaylandBufferManager::ScheduleBufferSwap",
+                                              const gfx::Rect& damage_region) {
+  TRACE_EVENT1("wayland", "WaylandBufferManager::ScheduleSwapBuffer",
                "Buffer id", buffer_id);
 
   if (!ValidateDataFromGpu(widget, buffer_id))
@@ -105,11 +103,11 @@ bool WaylandBufferManager::ScheduleBufferSwap(gfx::AcceleratedWidget widget,
 
   Buffer* buffer = it->second.get();
   DCHECK(buffer);
+  DCHECK(!buffer->swapped && !buffer->presented);
 
   // Assign a widget to this buffer, which is used to find a corresponding
   // WaylandWindow.
   buffer->widget = widget;
-  buffer->buffer_swap_callback = std::move(callback);
   buffer->damage_region = damage_region;
 
   if (buffer->wl_buffer) {
@@ -129,15 +127,7 @@ bool WaylandBufferManager::DestroyBuffer(uint32_t buffer_id) {
     error_message_ = "Trying to destroy non-existing buffer";
     return false;
   }
-  // It can happen that a buffer is destroyed before a frame callback comes.
-  // Thus, just mark this as a successful swap, which is ok to do.
-  Buffer* buffer = it->second.get();
-  if (!buffer->buffer_swap_callback.is_null()) {
-    std::move(buffer->buffer_swap_callback)
-        .Run(gfx::SwapResult::SWAP_ACK,
-             gfx::PresentationFeedback(base::TimeTicks::Now(),
-                                       base::TimeDelta(), 0));
-  }
+
   buffers_.erase(it);
 
   connection_->ScheduleFlush();
@@ -282,10 +272,47 @@ void WaylandBufferManager::OnCreateBufferComplete(
     SwapBuffer(buffer);
 }
 
-void WaylandBufferManager::OnBufferSwapped(Buffer* buffer) {
-  DCHECK(!buffer->buffer_swap_callback.is_null());
-  std::move(buffer->buffer_swap_callback)
-      .Run(buffer->swap_result, std::move(buffer->feedback));
+void WaylandBufferManager::OnSubmission(Buffer* buffer,
+                                        const gfx::SwapResult& swap_result) {
+  DCHECK(!buffer->swapped);
+
+  buffer->wl_frame_callback.reset();
+  buffer->swapped = true;
+  connection_->OnSubmission(buffer->widget, buffer->buffer_id,
+                            gfx::SwapResult::SWAP_ACK);
+
+  // If presentation feedback is not supported, use a fake feedback.
+  if (!connection_->presentation()) {
+    DCHECK(!buffer->wp_presentation_feedback && !buffer->presented);
+    OnPresentation(buffer, gfx::PresentationFeedback(base::TimeTicks::Now(),
+                                                     base::TimeDelta(), 0));
+  } else if (buffer->presented) {
+    DCHECK(!buffer->wp_presentation_feedback);
+    // If the buffer has been presented before the frame callback aka
+    // completion callback (in the future, release callback is going to be
+    // used), present the feedback to the GPU.
+    OnPresentation(buffer, buffer->feedback);
+  } else {
+    DCHECK(buffer->wp_presentation_feedback);
+  }
+}
+
+void WaylandBufferManager::OnPresentation(
+    Buffer* buffer,
+    const gfx::PresentationFeedback& feedback) {
+  buffer->presented = true;
+  buffer->feedback = feedback;
+
+  // If buffer has already been swapped, we can safely notify about the
+  // presentation as well.
+  if (buffer->swapped) {
+    connection_->OnPresentation(buffer->widget, buffer->buffer_id,
+                                buffer->feedback);
+
+    // Reset the status so that DCHECK passes in ::ScheduleBufferSwap call.
+    buffer->presented = false;
+    buffer->swapped = false;
+  }
 }
 
 // static
@@ -294,27 +321,15 @@ void WaylandBufferManager::FrameCallbackDone(void* data,
                                              uint32_t time) {
   WaylandBufferManager* self = static_cast<WaylandBufferManager*>(data);
   DCHECK(self);
+
   for (auto& item : self->buffers_) {
     Buffer* buffer = item.second.get();
     if (buffer->wl_frame_callback.get() == callback) {
-      buffer->swap_result = gfx::SwapResult::SWAP_ACK;
       buffer->wl_frame_callback.reset();
-
-      // If presentation feedback is not supported, use a fake feedback
-      if (!self->connection_->presentation()) {
-        buffer->feedback = gfx::PresentationFeedback(base::TimeTicks::Now(),
-                                                     base::TimeDelta(), 0);
-      }
-      // If presentation feedback event either has already been fired or
-      // has not been set, trigger swap callback.
-      if (!buffer->wp_presentation_feedback)
-        self->OnBufferSwapped(buffer);
-
+      self->OnSubmission(buffer, gfx::SwapResult::SWAP_ACK);
       return;
     }
   }
-
-  NOTREACHED();
 }
 
 // static
@@ -338,29 +353,20 @@ void WaylandBufferManager::FeedbackPresented(
     uint32_t flags) {
   WaylandBufferManager* self = static_cast<WaylandBufferManager*>(data);
   DCHECK(self);
-
   for (auto& item : self->buffers_) {
     Buffer* buffer = item.second.get();
     if (buffer->wp_presentation_feedback.get() == wp_presentation_feedback) {
-      buffer->feedback = gfx::PresentationFeedback(
-          GetPresentationFeedbackTimeStamp(tv_sec_hi, tv_sec_lo, tv_nsec),
-          base::TimeDelta::FromNanoseconds(refresh),
-          GetPresentationKindFlags(flags));
+      DCHECK(!buffer->presented);
       buffer->wp_presentation_feedback.reset();
-
-      // Some compositors not always fire PresentationFeedback and Frame
-      // events in the same order (i.e, frame callbacks coming always before
-      // feedback presented/discaded ones). So, check FrameCallbackDone has
-      // already been called at this point, if yes, trigger the swap callback.
-      // otherwise it will be triggered in the upcoming frame callback.
-      if (!buffer->wl_frame_callback)
-        self->OnBufferSwapped(buffer);
-
+      self->OnPresentation(
+          buffer,
+          gfx::PresentationFeedback(
+              GetPresentationFeedbackTimeStamp(tv_sec_hi, tv_sec_lo, tv_nsec),
+              base::TimeDelta::FromNanoseconds(refresh),
+              GetPresentationKindFlags(flags)));
       return;
     }
   }
-
-  NOTREACHED();
 }
 
 // static
@@ -369,27 +375,15 @@ void WaylandBufferManager::FeedbackDiscarded(
     struct wp_presentation_feedback* wp_presentation_feedback) {
   WaylandBufferManager* self = static_cast<WaylandBufferManager*>(data);
   DCHECK(self);
-
   for (auto& item : self->buffers_) {
     Buffer* buffer = item.second.get();
     if (buffer->wp_presentation_feedback.get() == wp_presentation_feedback) {
-      // Frame callback must come before a feedback is presented.
-      buffer->feedback = gfx::PresentationFeedback::Failure();
+      DCHECK(!buffer->presented);
       buffer->wp_presentation_feedback.reset();
-
-      // Some compositors not always fire PresentationFeedback and Frame
-      // events in the same order (i.e, frame callbacks coming always before
-      // feedback presented/discaded ones). So, check FrameCallbackDone has
-      // already been called at this point, if yes, trigger the swap callback.
-      // Otherwise it will be triggered in the upcoming frame callback.
-      if (!buffer->wl_frame_callback)
-        self->OnBufferSwapped(buffer);
-
+      self->OnPresentation(buffer, gfx::PresentationFeedback::Failure());
       return;
     }
   }
-
-  NOTREACHED();
 }
 
 }  // namespace ui
diff --git a/ui/ozone/platform/wayland/host/wayland_buffer_manager.h b/ui/ozone/platform/wayland/host/wayland_buffer_manager.h
index 633eba0c9e34..f4b0183cc3a1 100644
--- a/ui/ozone/platform/wayland/host/wayland_buffer_manager.h
+++ b/ui/ozone/platform/wayland/host/wayland_buffer_manager.h
@@ -49,11 +49,13 @@ class WaylandBufferManager {
   // Assigns a wl_buffer with |buffer_id| to a window with the same |widget|. On
   // error, false is returned and |error_message_| is set. A |damage_region|
   // identifies which part of the buffer is updated. If an empty region is
-  // provided, the whole buffer is updated.
+  // provided, the whole buffer is updated. Once a frame callback or
+  // presentation callback is received, WaylandConnection::OnSubmission and
+  // WaylandConnection::OnPresentation are called. Though, it is guaranteed
+  // OnPresentation won't be called earlier than OnSubmission.
   bool ScheduleBufferSwap(gfx::AcceleratedWidget widget,
                           uint32_t buffer_id,
-                          const gfx::Rect& damage_region,
-                          wl::BufferSwapCallback callback);
+                          const gfx::Rect& damage_region);
 
   // Destroys a buffer with |buffer_id| in |buffers_|. On error, false is
   // returned and |error_message_| is set.
@@ -71,13 +73,16 @@ class WaylandBufferManager {
   // to, its buffer id for simplier buffer management and other members specific
   // to this Buffer object on run-time.
   struct Buffer {
-    Buffer();
-    explicit Buffer(const gfx::Size& buffer_size);
+    Buffer() = delete;
+    Buffer(const gfx::Size& buffer_size, uint32_t buffer_id);
     ~Buffer();
 
     // Actual buffer size.
     const gfx::Size size;
 
+    // The id of the buffer.
+    const uint32_t buffer_id;
+
     // Widget to attached/being attach WaylandWindow.
     gfx::AcceleratedWidget widget = gfx::kNullAcceleratedWidget;
 
@@ -86,9 +91,6 @@ class WaylandBufferManager {
     // repainted.
     gfx::Rect damage_region;
 
-    // A buffer swap result once the buffer is committed.
-    gfx::SwapResult swap_result;
-
     // A feedback, which is received if a presentation feedback protocol is
     // supported.
     gfx::PresentationFeedback feedback;
@@ -96,9 +98,9 @@ class WaylandBufferManager {
     // A wl_buffer backed by a dmabuf created on the GPU side.
     wl::Object<struct wl_buffer> wl_buffer;
 
-    // A callback, which is called once the |wl_frame_callback| from the server
-    // is received.
-    wl::BufferSwapCallback buffer_swap_callback;
+    // Provide the status of this buffer. Reset on each new swap.
+    bool swapped = false;
+    bool presented = false;
 
     // A Wayland callback, which is triggered once wl_buffer has been committed
     // and it is right time to notify the GPU that it can start a new drawing
@@ -133,7 +135,9 @@ class WaylandBufferManager {
   void OnCreateBufferComplete(uint32_t buffer_id,
                               wl::Object<struct wl_buffer> new_buffer);
 
-  void OnBufferSwapped(Buffer* buffer);
+  void OnSubmission(Buffer* buffer, const gfx::SwapResult& swap_result);
+  void OnPresentation(Buffer* buffer,
+                      const gfx::PresentationFeedback& feedback);
 
   // wl_callback_listener
   static void FrameCallbackDone(void* data,
diff --git a/ui/ozone/platform/wayland/host/wayland_connection.cc b/ui/ozone/platform/wayland/host/wayland_connection.cc
index 4eb8db596fdb..7604e9abd4a4 100644
--- a/ui/ozone/platform/wayland/host/wayland_connection.cc
+++ b/ui/ozone/platform/wayland/host/wayland_connection.cc
@@ -182,6 +182,11 @@ int WaylandConnection::GetKeyboardModifiers() const {
   return modifiers;
 }
 
+void WaylandConnection::SetWaylandConnectionClient(
+    ozone::mojom::WaylandConnectionClientAssociatedPtrInfo client) {
+  client_associated_ptr_.Bind(std::move(client));
+}
+
 void WaylandConnection::CreateZwpLinuxDmabuf(
     base::File file,
     uint32_t width,
@@ -211,18 +216,14 @@ void WaylandConnection::DestroyZwpLinuxDmabuf(uint32_t buffer_id) {
   }
 }
 
-void WaylandConnection::ScheduleBufferSwap(
-    gfx::AcceleratedWidget widget,
-    uint32_t buffer_id,
-    const gfx::Rect& damage_region,
-    ScheduleBufferSwapCallback callback) {
+void WaylandConnection::ScheduleBufferSwap(gfx::AcceleratedWidget widget,
+                                           uint32_t buffer_id,
+                                           const gfx::Rect& damage_region) {
   DCHECK(base::MessageLoopCurrentForUI::IsSet());
 
   CHECK(buffer_manager_);
-  if (!buffer_manager_->ScheduleBufferSwap(widget, buffer_id, damage_region,
-                                           std::move(callback))) {
+  if (!buffer_manager_->ScheduleBufferSwap(widget, buffer_id, damage_region))
     TerminateGpuProcess(buffer_manager_->error_message());
-  }
 }
 
 void WaylandConnection::CreateShmBufferForWidget(gfx::AcceleratedWidget widget,
@@ -248,6 +249,21 @@ void WaylandConnection::DestroyShmBuffer(gfx::AcceleratedWidget widget) {
     TerminateGpuProcess("Failed to destroy SHM buffer.");
 }
 
+void WaylandConnection::OnSubmission(gfx::AcceleratedWidget widget,
+                                     uint32_t buffer_id,
+                                     const gfx::SwapResult& swap_result) {
+  DCHECK(client_associated_ptr_);
+  client_associated_ptr_->OnSubmission(widget, buffer_id, swap_result);
+}
+
+void WaylandConnection::OnPresentation(
+    gfx::AcceleratedWidget widget,
+    uint32_t buffer_id,
+    const gfx::PresentationFeedback& feedback) {
+  DCHECK(client_associated_ptr_);
+  client_associated_ptr_->OnPresentation(widget, buffer_id, feedback);
+}
+
 PlatformClipboard* WaylandConnection::GetPlatformClipboard() {
   return this;
 }
@@ -293,7 +309,8 @@ ozone::mojom::WaylandConnectionPtr WaylandConnection::BindInterface() {
 }
 
 void WaylandConnection::OnChannelDestroyed() {
-  binding_.Unbind();
+  client_associated_ptr_.reset();
+  binding_.Close();
   if (buffer_manager_)
     buffer_manager_->ClearState();
 }
diff --git a/ui/ozone/platform/wayland/host/wayland_connection.h b/ui/ozone/platform/wayland/host/wayland_connection.h
index c1ec0412bee6..2edbdb7e403d 100644
--- a/ui/ozone/platform/wayland/host/wayland_connection.h
+++ b/ui/ozone/platform/wayland/host/wayland_connection.h
@@ -52,6 +52,8 @@ class WaylandConnection : public PlatformEventSource,
   //
   // These overridden methods below are invoked by the GPU when hardware
   // accelerated rendering is used.
+  void SetWaylandConnectionClient(
+      ozone::mojom::WaylandConnectionClientAssociatedPtrInfo client) override;
   //
   // Called by the GPU and asks to import a wl_buffer based on a gbm file
   // descriptor.
@@ -68,13 +70,14 @@ class WaylandConnection : public PlatformEventSource,
   void DestroyZwpLinuxDmabuf(uint32_t buffer_id) override;
   // Called by the GPU and asks to attach a wl_buffer with a |buffer_id| to a
   // WaylandWindow with the specified |widget|.
+  // Calls OnSubmission and OnPresentation on successful swap and pixels
+  // presented.
   void ScheduleBufferSwap(gfx::AcceleratedWidget widget,
                           uint32_t buffer_id,
-                          const gfx::Rect& damage_region,
-                          ScheduleBufferSwapCallback callback) override;
+                          const gfx::Rect& damage_region) override;
   // These overridden methods below are invoked by the GPU when hardware
   // accelerated rendering is not used. Check comments in the
-  // ui/ozone/public/interfaces/wayland/host/wayland_connection.mojom.
+  // ui/ozone/public/interfaces/wayland/wayland_connection.mojom.
   void CreateShmBufferForWidget(gfx::AcceleratedWidget widget,
                                 base::File file,
                                 uint64_t length,
@@ -83,6 +86,20 @@ class WaylandConnection : public PlatformEventSource,
                                  const gfx::Rect& damage) override;
   void DestroyShmBuffer(gfx::AcceleratedWidget widget) override;
 
+  // These methods are exclusively used by the WaylandBufferManager to notify
+  // the |client_associated_ptr_| about buffer swaps' results.
+  // TODO(msisov): move these and the above mojo methods into the
+  // WaylandBufferManager and establish end-to-end communication with
+  // WaylandBufferManagerGpu and WaylandBufferManagerHost instead (basically, to
+  // avoid having the WaylandConnection as proxy in between).
+  // https://crbug.com/947411
+  void OnSubmission(gfx::AcceleratedWidget widget,
+                    uint32_t buffer_id,
+                    const gfx::SwapResult& swap_result);
+  void OnPresentation(gfx::AcceleratedWidget widget,
+                      uint32_t buffer_id,
+                      const gfx::PresentationFeedback& feedback);
+
   // Schedules a flush of the Wayland connection.
   void ScheduleFlush();
 
@@ -278,6 +295,7 @@ class WaylandConnection : public PlatformEventSource,
   // Stores the callback to be invoked upon data reading from clipboard.
   RequestDataClosure read_clipboard_closure_;
 
+  ozone::mojom::WaylandConnectionClientAssociatedPtr client_associated_ptr_;
   mojo::Binding<ozone::mojom::WaylandConnection> binding_;
 
   // A callback, which is used to terminate a GPU process in case of invalid
diff --git a/ui/ozone/platform/wayland/ozone_platform_wayland.cc b/ui/ozone/platform/wayland/ozone_platform_wayland.cc
index 2aa399952736..c95344355fa2 100644
--- a/ui/ozone/platform/wayland/ozone_platform_wayland.cc
+++ b/ui/ozone/platform/wayland/ozone_platform_wayland.cc
@@ -167,8 +167,10 @@ class OzonePlatformWayland : public OzonePlatform {
   }
 
   void InitializeGPU(const InitParams& args) override {
-    proxy_.reset(new WaylandConnectionProxy(connection_.get()));
-    surface_factory_.reset(new WaylandSurfaceFactory(proxy_.get()));
+    surface_factory_ = std::make_unique<WaylandSurfaceFactory>();
+    proxy_ = std::make_unique<WaylandConnectionProxy>(connection_.get(),
+                                                      surface_factory_.get());
+    surface_factory_->SetProxy(proxy_.get());
 #if defined(WAYLAND_GBM)
     const base::FilePath drm_node_path = path_finder_.GetDrmRenderNodePath();
     if (drm_node_path.empty()) {
diff --git a/ui/ozone/platform/wayland/test/wayland_test.cc b/ui/ozone/platform/wayland/test/wayland_test.cc
index e4e97db49539..55b15076cde3 100644
--- a/ui/ozone/platform/wayland/test/wayland_test.cc
+++ b/ui/ozone/platform/wayland/test/wayland_test.cc
@@ -28,7 +28,8 @@ WaylandTest::WaylandTest() {
       std::make_unique<StubKeyboardLayoutEngine>());
 #endif
   connection_.reset(new WaylandConnection);
-  connection_proxy_.reset(new WaylandConnectionProxy(connection_.get()));
+  connection_proxy_.reset(
+      new WaylandConnectionProxy(connection_.get(), nullptr));
   window_ = std::make_unique<WaylandWindow>(&delegate_, connection_.get());
 }
 
diff --git a/ui/ozone/public/interfaces/wayland/wayland_connection.mojom b/ui/ozone/public/interfaces/wayland/wayland_connection.mojom
index f7fc67762911..713ac9a210e7 100644
--- a/ui/ozone/public/interfaces/wayland/wayland_connection.mojom
+++ b/ui/ozone/public/interfaces/wayland/wayland_connection.mojom
@@ -14,6 +14,9 @@ import "ui/gfx/mojo/swap_result.mojom";
 // Used by the GPU for communication with a WaylandConnection on the browser
 // process.
 interface WaylandConnection {
+  // Sets up an associated pipe between the Client and Host.
+  SetWaylandConnectionClient(associated WaylandConnectionClient client);
+
   // Methods used for hardware accelerated rendering:
   //
   // Asks Wayland to create a wl_buffer based on the dmabuf |file| descriptor.
@@ -32,9 +35,7 @@ interface WaylandConnection {
 
   // Swaps wl_buffers for a WaylandWindow with the following |widget|.
   ScheduleBufferSwap(gfx.mojom.AcceleratedWidget widget, uint32 buffer_id,
-                     gfx.mojom.Rect damage_region)
-      => (gfx.mojom.SwapResult swap_result,
-          gfx.mojom.PresentationFeedback feedback);
+                     gfx.mojom.Rect damage_region);
 
   // Methods used for software rendering:
   //
@@ -65,4 +66,14 @@ interface WaylandConnectionClient {
   // avoid using zwp_linux_dmabuf protocol, which means using wl_egl_surface in
   // a single process mode, and software rendering in a multiple process mode.
   ResetGbmDevice();
+
+  // Signals about swap completion.
+  OnSubmission(gfx.mojom.AcceleratedWidget widget,
+               uint32 buffer_id,
+               gfx.mojom.SwapResult swap_result);
+
+  // Signals about presentation.
+  OnPresentation(gfx.mojom.AcceleratedWidget widget,
+                 uint32 buffer_id,
+                 gfx.mojom.PresentationFeedback feedback);
 };
-- 
2.17.1

